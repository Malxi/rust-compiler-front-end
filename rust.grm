(* rust.yacc *)
open DataTypes

fun yaccLog(msg) = ErrorMsg.yaccLog (msg)
fun error(pos, msg) = ErrorMsg.error pos

%%
%term EOF
    | AS | BREAK | CONST | CONTINUE | CRATE | ELSE | ENUM | EXTERN     
        | FALSE | FN | FOR | IF | IMPL | IN | LET | LOOP | MATCH | MOD | MOVE
        | MUT | PUB | REF | RETURN | SELFVALUE | SELFTYPE | STATIC | STRUCT 
        | SUPER | TRAIT | TRUE | TYPE | UNSAFE | USE | WHERE | WHILE | DYN
    | ABSTRACT | BECOME | BOX | DO | FINAL | MACRO | OVERRIDE
        | PRIV | TYPEOF | UNSIZED | VIRTUAL | YIELD
        | ASYNC | AWAIT | TRY
    | UNION | STATICLIFETIME
    | IDENT of string
    | CHAR_LIT of string 
        | STR_LIT of string | RAW_STR_LIT of string
        | BYTE_LIT of string | BYTE_STR_LIT of string | RAW_BYTE_STR_LIT of string
        | INTEGER_LIT of string | TUPLE_INDEX of string 
        | FLOAT_LIT of string
        | INTEGER_SUFFIX of string | FLOAT_SUFFIX of string
    | LIFETIME_OR_LABEL of string | LIFETIME_TOKEN of string
    | PLUS | MINUS | STAR | SLASH | PERCENT | CARET
        | NOT | AND | OR | ANDAND | OROR | SHL | SHR
        | PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | PERCENTEQ | CARETEQ | ANDEQ | OREQ
        | SHLEQ | SHREQ | EQ | EQEQ
        | NE | GT | LT | GE | LE
        | AT | UNDERSCORE | DOT | DOTDOT | DOTDOTDOT | DOTDOTEQ
        | COMMA | SEMI | COLON | PATHSEP | RARROW | FATARROW | POUND | DOLLAR | QUESTION
        | LBRACE | RBRACE | LBRACKET | RBRACKET | LPARENT | RPARENT
        | INNER_DOC_COMMENT of string | OUTER_DOC_COMMENT of string
        | SHEBANG | SHEBANG_LINE of string
    | LOWER_THAN_LPARENT | LOWER_THAN_PATHSEP | LOWER_THAN_EXPR | LOWER_THAN_COLON | LOWER_THAN_PLUS
    | LAMBDA | SHIFTPLUS | FORTYPE | RANGE
%nonterm shr of int | ge of int | shreq of int
        | crate of Crate | inner_attrs of InnerAttribute list | items of Item list
        | outer_attrs of OuterAttribute list
        | inner_attr of InnerAttribute | outer_attr of OuterAttribute | meta_item of MetaItem 
        | meta_seq of MetaItemInner list | meta_seq_expansion of MetaItemInner list | meta_item_inner of MetaItemInner

        | simple_path of PathSeg list | path_segment of PathSeg
        | path_in_exp of PathInExpression | path_in_exp_with_generic of PathSeg list
        | qualified_path_in_exp of QualifiedPathInExpression | qualified_path_in_type of QualifiedPathInType
        | type_path of TypePath | type_path_with_generic_fn of PathSeg list 
        | type_path_fn of TypePathFn | type_path_fn_inputs of Type list | type_path_fn_inputs_expansion of Type list
        | generic_args of GenericArgs | generic_args_lifetimes of Lifetime list
        | generic_args_types of Type list | generic_args_bindings of Binding list
        | generic_args_binding of Binding

        | item of Item | vis_item of VisItem | macro_item of MacroItem
        | visibility of Visibility | item_type of ItemType
        | use_tree of UseTree | use_tree_multi of UseTree list | use_tree_multi_expansion of UseTree list
        | patterns of Pattern | lit_pat of Pattern 
        | id_pat of Pattern | binding_mode of BindingMode
        | wildcard_pat of Pattern 
        | range_pat of Pattern | range_pat_bound of RangePatternBound
        | reference_pat of Pattern
        | struct_pat of Pattern | struct_pat_elements of StructPatternElements 
        | struct_pat_fields of StructPatternField list 
        | struct_pat_etcetera of StructPatternEtCetera | struct_pat_field of StructPatternField
        | tuple_struct_pat of Pattern
        | tuple_or_grouped_pat of Pattern | tuple_pat_items of Pattern list
        | grouped_pat | slice_pat of Pattern | path_pat of Pattern
        | types of Type | types_expansion of Type list | types_noqpt of Type
        | maybe_named_bare_func_parameters of MaybeNamedParam list 
        | maybe_named_bare_func_parameters_variadic of MaybeNamedParam list | maybe_named_param of MaybeNamedParam
        | generics of Generics | maybe_generics of Generics option | generic_params of GenericParams | maybe_visibility of Visibility
        | where_clause of WhereClause | maybe_where_clause of WhereClause option | where_clause_expansion of WhereClauseItem list
        | where_clause_item of WhereClauseItem | lifetime_where_clause_item of WhereClauseItem | type_bound_where_clause_item of WhereClauseItem
        | lifetime_params of LifetimeParam list | lifetime_param of LifetimeParam | lifetime_params_expansion of LifetimeParam list
        | type_params of TypeParam list | type_params_expansion of TypeParam list | type_param of TypeParam | maybe_type_param
        | maybe_lifetime_param | maybe_colon_lifetime_bounds of LifetimeBounds option | lifetime_param_tail | maybe_colon_type_bounds of TypeParamBounds option
        | maybe_comma | maybe_plus | maybe_ques | maybe_not | maybe_outer_attr of OuterAttribute option
        | function of ItemType | func_qualifier of FunctionQualifier list | maybe_unsafe of Unsafe option | abi of Abi | maybe_abi of Abi option
        | func_parameters of FunctionParam list | maybe_func_parameters of FunctionParam list| func_param of FunctionParam | func_parameters_expansion of FunctionParam list
        | func_return_type of Type | maybe_func_return_type of Type option
        | struct_struct of StructType| struct_fields of StructField list | struct_field of StructField 
        | maybe_struct_fields of StructField list | struct_fields_expansion of StructField list
        | tuple_struct of StructType | tuple_fields of TupleField list | tuple_field of TupleField 
        | maybe_tuple_fields of TupleField list | tuple_fields_expansion of TupleField list
        | enum_items of EnumItem list | maybe_enum_items of EnumItem list | enum_items_expansion of EnumItem list 
        | enum_item of EnumItem | enum_item_tuple of EnumItemType | enum_item_struct of EnumItemType | enum_item_discriminant of EnumItemType
        | type_alias of ItemType | constant_item of ItemType
        | maybe_type_param_bounds of TypeParamBounds option | type_param_bounds of TypeParamBounds
        | type_param_bounds_expansion of TypeParamBound list | type_param_bound of TypeParamBound
        | lifetime of Lifetime | lifetime_bounds of LifetimeBounds | lifetime_bounds_expansion of Lifetime list
        | maybe_lifetime of Lifetime option
        | trait_bound of TraitBound | for_lifetimes of ForLifetimes | maybe_for_lifetimes of ForLifetimes option
        | trait_items of TraitItem list | trait_item of TraitItem 
        | trait_func of TraitItemType | trait_method of TraitItemType | trait_const of TraitItemType | trait_type of TraitItemType
        | trait_func_decl of TraitFuncDecl | trait_method_decl of TraitMethodDecl
        | macro_invocation of MacroItem | macro_invocation_semi of MacroItem 
        | macro_rules_definition of MacroItem | macro_rules_def of MacroRulesDef
        | macro_rules of MacroRule list | macro_rules_expansion of MacroRule list 
        | macro_rule of MacroRule | macro_matcher of MacroMatcher | macro_transcriber of TokenTree 
        | macro_match of MacroMatch | macro_matches of MacroMatch list
        | macro_frag_spec of Identifer | macro_rep_sep of Token | macro_kleene_op of MacroKleeneOp
        | trait_func_parameters of TraitFunctionParam list | trait_func_param of TraitFunctionParam 
        | maybe_trait_func_parameters of TraitFunctionParam list | trait_func_parameters_expansion of TraitFunctionParam list
        | self_param of SelfParam| maybe_and_or_lifetime | maybe_mut of Mutability
        | inherent_impl of ItemType | trait_impl of ItemType
        | inherent_impl_items of InherentImplItem list | inherent_impl_items_expansion of InherentImplItem list | inherent_impl_item of InherentImplItem
        | trait_impl_items  of TraitImplItem list | trait_impl_items_expansion of TraitImplItem list | trait_impl_item of TraitImplItem
        | method of Method
        | extern_block of ItemType | external_items of ExternalItem list| external_item of ExternalItem 
        | external_static_item of ExternalItemType | external_func_item of ExternalItemType
        | maybe_named_func_parameters of ExternFunctionParameter
        | named_func_parameters of ExternFunctionParameter | named_func_parameters_expansion of NamedFunctionParam list
        | named_func_parameters_with_variadics of ExternFunctionParameter| named_func_param of NamedFunctionParam

        | maybe_statements of Statement list| statements of Statement list
        | statements_expansion of Statement list| statement of Statement 
        | let_statement of LetStatement | exp_statement of Expression
        | expressions of Expression list | expression of Expression | exp_nostruct of Expression 
        | exp_nostruct_nolazybop of Expression
        | exp_without_block of Expression 
        | lit_exp of Expression | str_lit of Token | bool_lit of Token
        | op_exp of Expression | grouped_exp of Expression
        | array_exp of Expression | array_elements of Expression list 
        | index_exp of Expression
        | tuple_exp of Expression | tuple_elements of Expression list | tuple_elements_expansion of Expression list 
        | tuple_index_exp of Expression
        | struct_exp of Expression| struct_exp_struct of Expression | struct_exp_tuple | struct_exp_unit
        | struct_exp_fields of StructOrEnumExprField list | struct_base of StructBase | struct_exp_field of StructOrEnumExprField
        | enum_var_exp | enum_exp_struct | enum_exp_tuple | enum_exp_field_less 
        | enum_exp_fields | enum_exp_fields_expansion | enum_exp_field
        | call_exp of Expression | call_params of Expression list 
        | maybe_call_params of Expression list | call_params_expansion of Expression list
        | method_call_exp of Expression | field_exp of Expression
        | closure_exp of Expression | closure_parameters of ClosureParam list
        | closure_param of ClosureParam | closure_parameters_expansion of ClosureParam list
        | continue_exp of Expression | break_exp of Expression | range_exp of Expression
        | return_exp of Expression
        | exp_with_block of Expression | block_exp of Expression 
        | unsafe_block_exp of Expression
        | loop_exp of Expression | maybe_loop_label of LoopLabel option | if_exp of Expression| if_let_exp of Expression
        | match_exp of Expression | match_arms of MatchArm list | match_arms_expansion of MatchArm list
        | match_arms_clauses of MatchArm list | match_arms_clause of MatchArm 
        | noblock_match_clause of MatchArm | block_match_clause of MatchArm
        | match_arm of MatchArm | match_arm_patterns of Pattern list| match_arm_guard of MatchArmGuard
        | type_no_bounds of TypeNoBounds | types_noqpt_no_bounds of TypeNoBounds

        | noblock_exp of Expression | full_block_exp of Expression | exp_with_block_dot of Expression

        | token_trees of TokenTree list | token_tree of TokenTree | delim_token_tree of TokenTree
        | token_no_delim of Token | token_no_delim_kleene of Token 
        | token_no_delim_dollar of Token | token_no_delim_kleene_dollar of Token
%pos int
%eop EOF
%noshift EOF
%name Rust
%keyword AS BREAK CONST CONTINUE CRATE ELSE ENUM EXTERN
        FALSE FN FOR IF IMPL IN LET LOOP MATCH MOD MOVE
        MUT PUB REF RETURN SELFVALUE SELFTYPE STATIC STRUCT
        SUPER TRAIT TRUE TYPE UNSAFE USE WHERE WHILE
        ABSTRACT BECOME BOX DO FINAL MACRO OVERRIDE
        PRIV TYPEOF UNSIZED VIRTUAL YIELD

%nonassoc LAMBDA
%nonassoc SELFVALUE
%nonassoc MUT
%nonassoc IDENT
%nonassoc SHIFTPLUS
%nonassoc LOWER_THAN_PATHSEP
%nonassoc PATHSEP
%nonassoc LOWER_THAN_COLON
%nonassoc RARROW COLON

(* For solving shift/reduce conflicts in type and lifetime *)
(*
    // In where clauses, "for" should have greater precedence when used as
    // a higher ranked constraint than when used as the beginning of a
    // for_in_type (which is a ty)
*)
%nonassoc FORTYPE
%nonassoc FOR

%nonassoc QUESTION
%nonassoc BOX
%nonassoc DOTDOT
%nonassoc RETURN YIELD

%nonassoc LOWER_THAN_EXPR

%right EQ SHLEQ SHREQ PLUSEQ MINUSEQ ANDEQ OREQ STAREQ SLASHEQ CARETEQ PERCENTEQ DOTDOTEQ
%left OROR
%left ANDAND
%left EQEQ NE
%left LT GT LE GE
%left OR
%left CARET
%left AND
%left SHL SHR
%nonassoc LOWER_THAN_PLUS
%left PLUS MINUS
%nonassoc AS
%left STAR SLASH PERCENT

%nonassoc NOT
%nonassoc LOWER_THAN_LPARENT
%nonassoc LBRACE LBRACKET LPARENT DOT

%nonassoc RANGE

%verbose

%%
crate: SHEBANG_LINE inner_attrs items                          (Crate (Shebang (SOME SHEBANG_LINE), rev(inner_attrs), rev(items)))
        | inner_attrs items                                    (Crate (Shebang (NONE), rev(inner_attrs), rev(items)))

items: items item                                              (item::items)
        |                                                      ([])

item: outer_attrs vis_item                                     (VisItemType (rev(outer_attrs), vis_item))
    | outer_attrs macro_item                                   (MacroItemType (macro_item))

(* -----Macro------ *)
(* macro_invocation: simple_path NOT delim_token_tree              () *)
macro_invocation: path_in_exp NOT delim_token_tree              (MacroInvocation((path_in_exp, delim_token_tree)))

macro_item: macro_invocation_semi                               (yaccLog("macro_invocation_semi"); macro_invocation_semi)
            | macro_rules_definition                            (yaccLog("macro_rules_definition"); macro_rules_definition)

(* macro_invocation_semi: simple_path NOT 
                        LPARENT token_trees RPARENT SEMI        (MacroInvocationSemi)
                    | simple_path NOT 
                        LBRACKET token_trees RBRACKET SEMI      (MacroInvocationSemi)
                    | simple_path NOT 
                        LBRACE token_trees RBRACE               (MacroInvocationSemi) *)

macro_invocation_semi: path_in_exp NOT 
                        LPARENT token_trees RPARENT SEMI        (MacroInvocationSemi(path_in_exp, DTokenTree(ParentDelim, token_trees)))
                    | path_in_exp NOT 
                        LBRACKET token_trees RBRACKET SEMI      (MacroInvocationSemi(path_in_exp, DTokenTree(BracketDelim, token_trees)))
                    | path_in_exp NOT 
                        LBRACE token_trees RBRACE               (MacroInvocationSemi(path_in_exp, DTokenTree(BraceDelim, token_trees)))

token_trees: token_trees token_tree                             (token_tree::token_trees)
            |                                                   (nil)
token_tree: token_no_delim                                      (SToken(token_no_delim))
            | delim_token_tree                                  (delim_token_tree)
delim_token_tree: LPARENT token_trees RPARENT                   (DTokenTree(ParentDelim, token_trees))
                | LBRACKET token_trees RBRACKET                 (DTokenTree(BracketDelim, token_trees))
                | LBRACE token_trees RBRACE                     (DTokenTree(BraceDelim, token_trees))

(* the path_in_exp must be [macro_rules] *)
(* macro_rules_definition: simple_path NOT IDENT macro_rules_def   () *)
macro_rules_definition: path_in_exp NOT IDENT macro_rules_def   (MacroRulesDefinition(path_in_exp, Identifer(IDENT), macro_rules_def))
macro_rules_def: LPARENT macro_rules RPARENT SEMI               (MacroRulesDef(ParentDelim, macro_rules))
            | LBRACKET macro_rules RBRACKET SEMI                (MacroRulesDef(BracketDelim, macro_rules))
            | LBRACE macro_rules RBRACE                         (MacroRulesDef(BraceDelim, macro_rules))
macro_rules: macro_rule macro_rules_expansion SEMI              (rev(macro_rule::macro_rules_expansion))
            | macro_rule macro_rules_expansion                  (rev(macro_rule::macro_rules_expansion))
macro_rules_expansion: macro_rules_expansion SEMI macro_rule    (macro_rule::macro_rules_expansion)
                    |                                           (nil)
macro_rule: macro_matcher FATARROW macro_transcriber            (yaccLog("macro_rule"); MacroRule(macro_matcher, macro_transcriber))
macro_matcher: LPARENT macro_matches RPARENT                    (MacroMatcher(ParentDelim, rev(macro_matches)))
            | LBRACKET macro_matches RBRACKET                   (MacroMatcher(BracketDelim, rev(macro_matches)))
            | LBRACE macro_matches RBRACE                       (MacroMatcher(BraceDelim, rev(macro_matches)))
macro_matches: macro_matches macro_match                        (macro_match::macro_matches)
            |                                                   (nil)
macro_match: token_no_delim_dollar                              (MMTK(token_no_delim_dollar))
            | macro_matcher                                     (MMer(macro_matcher))
            | DOLLAR IDENT COLON macro_frag_spec                (MMBD(Identifer(IDENT), macro_frag_spec))
            | DOLLAR SELFVALUE COLON macro_frag_spec            (MMBD(Identifer("self"), macro_frag_spec))
            | DOLLAR LPARENT macro_match macro_matches RPARENT 
                macro_kleene_op                                 (MMs(rev(macro_match::macro_matches), NONE, macro_kleene_op))
            | DOLLAR LPARENT macro_match macro_matches RPARENT 
                macro_rep_sep macro_kleene_op                   (MMs(rev(macro_match::macro_matches), SOME(macro_rep_sep), macro_kleene_op))     
macro_frag_spec: IDENT                                          (Identifer(IDENT))
macro_rep_sep: token_no_delim_kleene                            (token_no_delim_kleene)
macro_kleene_op: STAR                                           (KleeneStar)
                | PLUS                                          (KleenePlus)
                | QUESTION                                      (KleeneQues)
macro_transcriber: delim_token_tree                             (delim_token_tree)

(* ------VisItem------ *)
vis_item: maybe_visibility item_type                            (VisItem(DefaultVis, item_type))

maybe_visibility: visibility                                    (visibility)
                    |                                           (DefaultVis)

visibility: PUB %prec LOWER_THAN_LPARENT                        (PubVis)
        | PUB LPARENT CRATE RPARENT                             (CrateVis)
        | PUB LPARENT SELFVALUE RPARENT                         (SelfVis)
        | PUB LPARENT SUPER RPARENT                             (SuperVis)
        | PUB LPARENT IN simple_path RPARENT                    (InVis (SimplePath(rev(simple_path))))
        (* | CRATE                                                 (CrateVis) *)

use_tree: simple_path                                           (yaccLog("use_tree:branch 1"); UseAlias (SimplePath(rev(simple_path)), NONE))
        | simple_path AS IDENT                                  (yaccLog("use_tree:branch 2"); UseAlias (SimplePath(rev(simple_path)), SOME(Identifer(IDENT))))
        | STAR                                                  (yaccLog("use_tree:branch 3"); UseAll (NONE))
        | PATHSEP STAR                                          (yaccLog("use_tree:branch 4"); UseAll (SOME(SimplePath([DefaultPS]))))
        | simple_path PATHSEP STAR                              (yaccLog("use_tree:branch 5"); UseAll (SOME(SimplePath(rev(simple_path)))))
        | use_tree_multi                                        (yaccLog("use_tree:branch 6"); UseList (NONE, use_tree_multi))
        | PATHSEP use_tree_multi                                (yaccLog("use_tree:branch 7"); UseList (SOME(SimplePath([DefaultPS])), use_tree_multi))
        | simple_path PATHSEP use_tree_multi                    (yaccLog("use_tree:branch 8"); UseList (SOME(SimplePath(rev(simple_path))), use_tree_multi))
use_tree_multi: LBRACE use_tree 
                use_tree_multi_expansion maybe_comma RBRACE     (use_tree::rev(use_tree_multi_expansion))
                | LBRACE RBRACE                                 ([])
use_tree_multi_expansion: use_tree_multi_expansion
                            COMMA use_tree                      (use_tree::use_tree_multi_expansion)
                        |                                       (nil)                       

inner_attrs: inner_attrs inner_attr                             (yaccLog("inner_attrs"); inner_attr::inner_attrs)
            |                                                   ([])
outer_attrs: outer_attrs outer_attr                             (yaccLog("outer_attrs"); outer_attr::outer_attrs)
            |                                                   ([])

maybe_outer_attr: outer_attr                                    (SOME(outer_attr))
                |                                               (NONE)
inner_attr: SHEBANG LBRACKET meta_item RBRACKET                 (yaccLog("inner_attr"); InnerAttribute(meta_item))
            | INNER_DOC_COMMENT                                 (InnerAttribute(AttrName (SimplePath([]))))
outer_attr: POUND LBRACKET meta_item RBRACKET                   (OuterAttribute meta_item)
            | OUTER_DOC_COMMENT                                 (OuterAttribute(AttrName (SimplePath([]))))

meta_item: simple_path EQ lit_exp                               (AttrKVPair(SimplePath(rev(simple_path)), lit_exp))
        | simple_path LPARENT meta_seq RPARENT                  (AttrSubs(SimplePath(rev(simple_path)), rev(meta_seq)))
        | simple_path LPARENT meta_seq COMMA RPARENT            (AttrSubs(SimplePath(rev(simple_path)), rev(meta_seq)))
        | simple_path LPARENT RPARENT                           (AttrSubs(SimplePath(rev(simple_path)), []))
        | simple_path %prec LOWER_THAN_LPARENT                  (AttrName (SimplePath(rev(simple_path))))

meta_seq: meta_item_inner                                       ([meta_item_inner])
        | meta_seq COMMA meta_item_inner                        (meta_item_inner::meta_seq)

meta_item_inner: meta_item                                      (MetaItem(meta_item))
                | lit_exp                                       (MetaLit(lit_exp))

(* rewrite simple path production*)
simple_path:  path_segment                                      ([path_segment])
            | PATHSEP path_segment                              ([path_segment, DefaultPS])
            | simple_path PATHSEP path_segment                  (path_segment::simple_path)
path_segment: IDENT                                             (IDPS(Identifer(IDENT)))
            | SUPER                                             (SuperPS)
            | SELFVALUE                                         (SelfValuePS)
            | CRATE                                             (CratePS)
            | DOLLAR CRATE                                      (DCratePS)

path_in_exp: path_in_exp_with_generic                                   (PathInExpression(rev(path_in_exp_with_generic)))
            | PATHSEP path_in_exp_with_generic                          (PathInExpression(rev(DefaultPS::path_in_exp_with_generic)))

path_in_exp_with_generic: path_segment                                  ([path_segment])
                        | SELFTYPE                                      ([SelfTypePS])
                        | path_in_exp_with_generic PATHSEP path_segment (path_segment::path_in_exp_with_generic)
                        | path_in_exp_with_generic PATHSEP SELFTYPE     (SelfTypePS::path_in_exp_with_generic)
                        | path_in_exp_with_generic PATHSEP generic_args (GenericPS(generic_args)::path_in_exp_with_generic)

generic_args: LT GT                                             (GenericArgs([], [], []))
            | LT generic_args_lifetimes maybe_comma GT          (GenericArgs(generic_args_lifetimes, [], []))
            | LT generic_args_types maybe_comma GT              (GenericArgs([], generic_args_types, []))
            | LT generic_args_bindings maybe_comma GT           (GenericArgs([], [], generic_args_bindings))
            | LT generic_args_types 
                COMMA generic_args_bindings maybe_comma GT      (GenericArgs([], generic_args_types, generic_args_bindings))
            | LT generic_args_lifetimes 
                COMMA generic_args_types GT                     (GenericArgs(generic_args_lifetimes, generic_args_types, []))
            | LT generic_args_lifetimes 
                COMMA generic_args_bindings GT                  (GenericArgs(generic_args_lifetimes, [], generic_args_bindings))
            | LT generic_args_lifetimes 
                COMMA generic_args_types 
                COMMA generic_args_bindings GT                  (GenericArgs(generic_args_lifetimes, generic_args_types, generic_args_bindings))
generic_args_lifetimes: generic_args_lifetimes COMMA lifetime   (lifetime::generic_args_lifetimes)
                        | lifetime                              ([lifetime])
generic_args_types: generic_args_types COMMA types              (types::generic_args_types)
                    | types                                     ([types])
generic_args_bindings: generic_args_bindings 
                    COMMA generic_args_binding                  (generic_args_binding::generic_args_bindings)
                    | generic_args_binding                      ([generic_args_binding])
generic_args_binding: IDENT EQ types                            (Binding(Identifer(IDENT), types))

qualified_path_in_exp: LT types GT 
                    PATHSEP path_in_exp_with_generic            (QualifiedPathInExpression(types, NONE, rev(path_in_exp_with_generic)))
                    | LT types AS type_path GT
                    PATHSEP path_in_exp_with_generic            (QualifiedPathInExpression(types, SOME(type_path), rev(path_in_exp_with_generic)))

qualified_path_in_type: LT types GT 
                    PATHSEP type_path_with_generic_fn           (QualifiedPathInType(types, NONE, rev(type_path_with_generic_fn)))
                    | LT types AS type_path GT
                    PATHSEP type_path_with_generic_fn           (QualifiedPathInType(types, SOME(type_path), rev(type_path_with_generic_fn)))

type_path: type_path_with_generic_fn %prec LOWER_THAN_PATHSEP   (TypePath(rev(type_path_with_generic_fn)))
        | PATHSEP type_path_with_generic_fn                     (TypePath(rev(type_path_with_generic_fn)))

type_path_with_generic_fn: path_segment                         ([path_segment])
                        | SELFTYPE                              ([SelfTypePS])
                        | type_path_with_generic_fn 
                            PATHSEP path_segment                (path_segment::type_path_with_generic_fn)
                        | type_path_with_generic_fn 
                            PATHSEP SELFTYPE                    (SelfTypePS::type_path_with_generic_fn)
                        | type_path_with_generic_fn generic_args(GenericPS(generic_args)::type_path_with_generic_fn)
                        | type_path_with_generic_fn type_path_fn(TypePathFnPS(type_path_fn)::type_path_with_generic_fn)
                  
type_path_fn: LPARENT RPARENT                                   (TypePathFn([], NONE))
            | LPARENT RPARENT RARROW types                      (TypePathFn([], SOME(types)))
            | LPARENT type_path_fn_inputs RPARENT               (TypePathFn(type_path_fn_inputs, NONE))
            | LPARENT type_path_fn_inputs RPARENT RARROW types  (TypePathFn(type_path_fn_inputs, SOME(types)))
type_path_fn_inputs: type_path_fn_inputs_expansion              (rev(type_path_fn_inputs_expansion))
                    | type_path_fn_inputs_expansion COMMA       (rev(type_path_fn_inputs_expansion))
type_path_fn_inputs_expansion: type_path_fn_inputs_expansion 
                            COMMA types                         (types::type_path_fn_inputs_expansion)
                            | types                             ([types])
                
maybe_where_clause: where_clause                                (SOME(where_clause))
                    |                                           (NONE)
where_clause: WHERE where_clause_expansion                      (WhereClause (rev (where_clause_expansion)))
            | WHERE where_clause_expansion where_clause_item    (WhereClause (where_clause_item::rev(where_clause_expansion)))
where_clause_expansion: where_clause_expansion 
                    where_clause_item COMMA                     (where_clause_item::where_clause_expansion)
                    |                                           (nil)
where_clause_item: lifetime_where_clause_item                   (lifetime_where_clause_item)
                    | type_bound_where_clause_item              (type_bound_where_clause_item)
lifetime_where_clause_item: lifetime COLON lifetime_bounds      (LifetimeWhereClauseItem(lifetime, lifetime_bounds))
type_bound_where_clause_item: maybe_for_lifetimes types COLON 
                            maybe_type_param_bounds             (TypeBoundWhereClauseItem(maybe_for_lifetimes, types, maybe_type_param_bounds))
maybe_generics: generics                                        (SOME(generics))
                |                                               (NONE)
maybe_for_lifetimes: for_lifetimes                              (SOME(for_lifetimes))
                    | %prec FORTYPE                             (NONE)
for_lifetimes: (* There is no definition in reference, 
            and following production comes from rust repository *)                
            FOR LT lifetime_params GT                           (ForLifetimes(LifetimeParams(rev(lifetime_params))))
            | FOR LT GT                                         (ForLifetimes(LifetimeParams([])))

(* There is a ambiguous token, SHR *)
generics: LT generic_params GT                                  (yaccLog("generics"); Generics(generic_params))
generic_params: lifetime_params                                 (GenericParams (LifetimeParams(rev(lifetime_params)), TypeParams([])))
                | lifetime_params COMMA                         (GenericParams (LifetimeParams(rev(lifetime_params)), TypeParams([])))
                | type_params                                   (GenericParams (LifetimeParams([]), TypeParams(rev(type_params))))
                | type_params COMMA                             (GenericParams (LifetimeParams([]), TypeParams(rev(type_params))))
                | lifetime_params COMMA type_params             (GenericParams (LifetimeParams(rev(lifetime_params)), TypeParams(rev(type_params))))
                | lifetime_params COMMA type_params COMMA       (GenericParams (LifetimeParams(rev(lifetime_params)), TypeParams(rev(type_params))))
                |                                               (GenericParams (LifetimeParams([]), TypeParams([])))
lifetime_params: lifetime_param                                 ([lifetime_param])
                | lifetime_params COMMA lifetime_param          (lifetime_param::lifetime_params)
type_params: type_param                                         ([type_param])
            | type_params COMMA type_param                      (type_param::type_params)
(* generic_params: lifetime_params                                 (yaccLog("generic_params:branch 1"))
                | lifetime_params_expansion type_params         (yaccLog("generic_params:branch 2")) *)
(* lifetime_params: lifetime_params_expansion 
                maybe_lifetime_param                            ()
maybe_lifetime_param: lifetime_param                            ()
                    |                                           ()
lifetime_params_expansion: lifetime_params_expansion
                            lifetime_param COMMA                (yaccLog("lifetime_params_expansion:branch 1"))
                        |                                       (yaccLog("lifetime_params_expansion:branch 2")) *)
(* type_params: type_params_expansion maybe_type_param             ()
type_params_expansion: type_params_expansion 
                    type_param COMMA                            (yaccLog("type_params_expansion:branch 1"))
                    |                                           (yaccLog("type_params_expansion:branch 2"))
maybe_type_param: type_param                                    ()
                |                                               () *)
lifetime_param: maybe_outer_attr
            LIFETIME_OR_LABEL maybe_colon_lifetime_bounds       (yaccLog("lifetime_param"); 
                                                                    LifetimeParam(maybe_outer_attr, 
                                                                            LifetimeOrLabel(LIFETIME_OR_LABEL), 
                                                                            maybe_colon_lifetime_bounds)
                                                                )
maybe_colon_lifetime_bounds: COLON lifetime_bounds              (SOME(lifetime_bounds))
                        |                                       (NONE)
type_param: maybe_outer_attr IDENT maybe_colon_type_bounds      (yaccLog("type_param:branch 1");
                                                                    TypeParam(maybe_outer_attr, Identifer(IDENT), maybe_colon_type_bounds, NONE)
                                                                )
            | maybe_outer_attr IDENT maybe_colon_type_bounds
                EQ types                                        (yaccLog("type_param:branch 2");
                                                                    TypeParam(maybe_outer_attr, Identifer(IDENT), maybe_colon_type_bounds, SOME(types))
                                                                )
maybe_colon_type_bounds: COLON                                  (NONE)
                        | COLON type_param_bounds               (SOME(type_param_bounds))
                        |                                       (NONE)

maybe_comma: COMMA                                              ()
            |                                                   ()
maybe_mut: MUT                                                  (Mut)
            |                                                   (NonMut)
maybe_plus: PLUS                                                ()
            |                                                   ()
maybe_ques: QUESTION                                            ()
            |                                                   ()
maybe_unsafe: UNSAFE                                            (SOME(Unsafe))
            |                                                   (NONE)

item_type: 
        MOD IDENT SEMI                                       (Module (Identifer(IDENT), NONE))
        | MOD IDENT LBRACE inner_attrs items RBRACE             (Module (Identifer(IDENT), SOME(ModuleBody(rev(inner_attrs), rev(items)))))
        | EXTERN CRATE IDENT SEMI                               (yaccLog("extern crate "^IDENT); ExternCrate (Identifer(IDENT), NONE))
        | EXTERN CRATE IDENT AS IDENT SEMI                      (yaccLog("extern crate "^IDENT1^" as"^IDENT2); ExternCrate (Identifer(IDENT1), SOME(Identifer(IDENT2))))
        | USE use_tree SEMI                                     (yaccLog("use_tree"); UseDeclaration(use_tree))
        | function                                              (yaccLog("function"); function)
        | type_alias                                            (yaccLog("type alias"); type_alias)
        | struct_struct                                         (yaccLog("struct struct"); Struct (struct_struct))
        | tuple_struct                                          (yaccLog("tuple struct"); Struct (tuple_struct))
        | ENUM IDENT maybe_generics maybe_where_clause
            LBRACE maybe_enum_items RBRACE                      (yaccLog("enumeration"); 
                                                                Enumeration (Identifer(IDENT), maybe_generics, 
                                                                maybe_where_clause, maybe_enum_items))
        | UNION IDENT maybe_generics maybe_where_clause 
            LBRACE struct_fields RBRACE                         (yaccLog("Union"); Union (Identifer(IDENT), maybe_generics, 
                                                                                        maybe_where_clause, struct_fields))
        | constant_item                                         (yaccLog("ConstantItem"); constant_item)
        | STATIC MUT IDENT COLON types EQ expression SEMI       (yaccLog("StaticItem"); StaticItem (Mut, Identifer(IDENT), types, expression))
        | STATIC IDENT COLON types EQ expression SEMI           (yaccLog("StaticItem"); StaticItem (NonMut, Identifer(IDENT), types, expression))
        | maybe_unsafe TRAIT IDENT maybe_generics
            maybe_colon_type_bounds maybe_where_clause
            LBRACE trait_items RBRACE                           (yaccLog("Trait"); Trait ({
                                                                    unsafe=maybe_unsafe, name=Identifer(IDENT), generic=maybe_generics, 
                                                                    tyb=maybe_colon_type_bounds, wh=maybe_where_clause, 
                                                                    traitItems=rev(trait_items)
                                                                }))
        | inherent_impl                                         (yaccLog("inherent_impl"); inherent_impl)
        | trait_impl                                            (yaccLog("trait_impl"); trait_impl)
        | extern_block                                          (yaccLog("extern_block"); extern_block)

type_alias: TYPE IDENT maybe_generics maybe_where_clause
            EQ types SEMI                                       (TypeAlias (Identifer(IDENT), maybe_generics, maybe_where_clause, types))        
constant_item: CONST IDENT COLON types EQ expression SEMI       (ConstantItem (Identifer(IDENT), types, expression))

function: func_qualifier FN IDENT maybe_generics
            LPARENT maybe_func_parameters RPARENT
            maybe_func_return_type
            maybe_where_clause
            block_exp                                           (Function({ qualifier=func_qualifier, generic=maybe_generics,
                                                                            name=Identifer(IDENT), params=maybe_func_parameters,
                                                                            ret=maybe_func_return_type, wh=maybe_where_clause,
                                                                            be=block_exp
                                                                        })
                                                                )

func_qualifier: CONST                                           ([ConstFQ])
                | CONST UNSAFE                                  ([ConstFQ, UnsafeFQ])
                | CONST EXTERN                                  ([ConstFQ, ExternFQ(NONE)])
                | CONST EXTERN abi                              ([ConstFQ, ExternFQ(SOME(abi))])
                | CONST UNSAFE EXTERN                           ([ConstFQ, UnsafeFQ, ExternFQ(NONE)])
                | CONST UNSAFE EXTERN abi                       ([ConstFQ, UnsafeFQ, ExternFQ(SOME(abi))])
                | UNSAFE                                        ([UnsafeFQ])
                | UNSAFE EXTERN                                 ([UnsafeFQ, ExternFQ(NONE)])
                | UNSAFE EXTERN abi                             ([UnsafeFQ, ExternFQ(SOME(abi))])
                | EXTERN                                        ([ExternFQ(NONE)])
                | EXTERN abi                                    ([ExternFQ(SOME(abi))])
                |                                               ([])

maybe_abi: abi                                                  (SOME(abi))
        |                                                       (NONE)

abi: STR_LIT                                                    (Abi(STR_LIT))
    | RAW_STR_LIT                                               (Abi(RAW_STR_LIT))

maybe_func_parameters: func_parameters                          (func_parameters)
                    |                                           ([])

func_parameters: func_param func_parameters_expansion 
                maybe_comma                                     (func_param::rev(func_parameters_expansion))

func_parameters_expansion: 
                        (* This is a left recursion to solve COMMA conflicts *)
                        func_parameters_expansion 
                        COMMA func_param                        (func_param::func_parameters_expansion)
                        |                                       (nil)

func_param: patterns COLON types                                (FunctionParam (patterns, types))

maybe_func_return_type: func_return_type                        (SOME(func_return_type))
                        |                                       (NONE)
func_return_type: RARROW types                                  (types)

struct_struct: STRUCT IDENT maybe_generics maybe_where_clause
                LBRACE maybe_struct_fields RBRACE               (StructStruct (Identifer(IDENT), maybe_generics, maybe_where_clause, maybe_struct_fields))
            | STRUCT IDENT maybe_generics maybe_where_clause
                SEMI                                            (UnitStruct (Identifer(IDENT), maybe_generics, maybe_where_clause))

maybe_struct_fields: struct_fields                              (struct_fields)
                    |                                           ([])
struct_fields: struct_field struct_fields_expansion maybe_comma (struct_field::rev(struct_fields_expansion))

struct_fields_expansion:
                        (* This is a left recursion to solve COMMA conflicts *)
                        struct_fields_expansion
                        COMMA struct_field                      (struct_field::struct_fields_expansion)
                        |                                       (nil)
struct_field: outer_attrs visibility IDENT COLON types          (StructField (rev(outer_attrs), visibility, Identifer(IDENT), types))
                | outer_attrs IDENT COLON types                 (StructField (rev(outer_attrs), DefaultVis, Identifer(IDENT), types))

tuple_struct: STRUCT IDENT maybe_generics 
                LPARENT maybe_tuple_fields 
                RPARENT maybe_where_clause SEMI                 (TupleStruct (Identifer(IDENT), maybe_generics, maybe_tuple_fields, maybe_where_clause))
maybe_tuple_fields: tuple_fields                                (tuple_fields)
                    |                                           ([])
tuple_fields: tuple_field tuple_fields_expansion maybe_comma    (tuple_field::rev(tuple_fields_expansion))
tuple_fields_expansion: 
                        (* This is a left recursion to solve COMMA conflicts *)
                        tuple_fields_expansion 
                        COMMA tuple_field                       (tuple_field::tuple_fields_expansion)
                        |                                       (nil)
tuple_field: outer_attrs visibility types                       (TupleField (rev(outer_attrs), visibility, types))
            | outer_attrs types                                 (TupleField (rev(outer_attrs), DefaultVis, types))

maybe_enum_items: enum_items                                    (enum_items)
                |                                               ([])
enum_items: enum_item enum_items_expansion maybe_comma          (yaccLog("enum_items"); enum_item::rev(enum_items_expansion))
enum_items_expansion: 
                    (* This is a left recursion to solve COMMA conflicts *)
                    enum_items_expansion COMMA enum_item        (enum_item::enum_items_expansion)
                    |                                           (nil)
enum_item: outer_attrs IDENT enum_item_tuple                    (EnumItem (rev(outer_attrs), Identifer(IDENT), SOME(enum_item_tuple)))
            | outer_attrs IDENT enum_item_struct                (EnumItem (rev(outer_attrs), Identifer(IDENT), SOME(enum_item_struct)))
            | outer_attrs IDENT enum_item_discriminant          (EnumItem (rev(outer_attrs), Identifer(IDENT), SOME(enum_item_discriminant)))
            | outer_attrs IDENT                                 (yaccLog("enum_item: branch 4"); EnumItem (rev(outer_attrs), Identifer(IDENT), NONE))

enum_item_tuple: LPARENT maybe_tuple_fields RPARENT             (EnumItemTuple (maybe_tuple_fields))
enum_item_struct: LBRACE maybe_struct_fields RBRACE             (EnumItemStruct (maybe_struct_fields))
enum_item_discriminant: EQ expression                           (EnumItemDiscriminant (expression))

trait_items: trait_items trait_item                             (trait_item::trait_items)
            |                                                   (nil)
trait_item: outer_attrs trait_func                              (TraitItem (outer_attrs, trait_func))
            | outer_attrs trait_method                          (TraitItem (outer_attrs, trait_method))
            | outer_attrs trait_const                           (TraitItem (outer_attrs, trait_const))
            | outer_attrs trait_type                            (TraitItem (outer_attrs, trait_type))
            | outer_attrs macro_invocation_semi                 (TraitItem (outer_attrs, TraitMIS(macro_invocation_semi)))

trait_func: trait_func_decl SEMI                                (TraitFunc (trait_func_decl, NONE))
            | trait_func_decl block_exp                         (TraitFunc (trait_func_decl, SOME (block_exp)))
trait_method: trait_method_decl SEMI                            (TraitMethod (trait_method_decl, NONE))
            | trait_method_decl block_exp                       (TraitMethod (trait_method_decl, SOME (block_exp)))
trait_func_decl: func_qualifier FN IDENT maybe_generics
                    LPARENT maybe_trait_func_parameters 
                    RPARENT maybe_func_return_type 
                    maybe_where_clause                          (TraitFuncDecl ({
                                                                    qualifier=func_qualifier, name=Identifer(IDENT), generic=maybe_generics, 
                                                                    params=maybe_trait_func_parameters, ret=maybe_func_return_type, 
                                                                    wh=maybe_where_clause
                                                                }))
maybe_trait_func_parameters: trait_func_parameters              (trait_func_parameters)
                                |                               ([])
trait_method_decl: func_qualifier FN IDENT maybe_generics
                    LPARENT self_param
                    trait_func_parameters_expansion maybe_comma
                    RPARENT maybe_func_return_type
                    maybe_where_clause                          (TraitMethodDecl({
                                                                    qualifier=func_qualifier, name=Identifer(IDENT), generic=maybe_generics, 
                                                                    selfParam=self_param, params=trait_func_parameters_expansion, ret=maybe_func_return_type, 
                                                                    wh=maybe_where_clause
                                                                }))
trait_func_parameters: trait_func_param 
                trait_func_parameters_expansion maybe_comma     (trait_func_param::rev(trait_func_parameters_expansion))
trait_func_parameters_expansion: 
    trait_func_parameters_expansion COMMA trait_func_param      (trait_func_param::trait_func_parameters_expansion)
                            |                                   (nil)
trait_func_param:  patterns COLON types                         (TraitFunctionParam (SOME(patterns), types))
                (* | types                                         (TraitFunctionParam (NONE, types)) *)
trait_const: CONST IDENT COLON types SEMI                       (TraitConst (Identifer(IDENT), types, NONE))
            | CONST IDENT COLON types EQ expression SEMI        (TraitConst (Identifer(IDENT), types, SOME(expression)))
trait_type: TYPE IDENT maybe_colon_type_bounds SEMI             (TraitType (Identifer(IDENT), maybe_colon_type_bounds))
maybe_type_param_bounds: type_param_bounds                      (SOME(type_param_bounds))
                        |                                       (NONE)
(* type_param_bounds: type_param_bound type_param_bounds_expansion (TypeParamBounds(type_param_bound::rev(type_param_bounds_expansion)))
                    | type_param_bound 
                    type_param_bounds_expansion PLUS            (TypeParamBounds(type_param_bound::rev(type_param_bounds_expansion)))
type_param_bounds_expansion: type_param_bounds_expansion
                            PLUS type_param_bound               (type_param_bound::type_param_bounds_expansion)
                        |                                       (nil) *)
type_param_bounds: type_param_bounds_expansion 
                    %prec LOWER_THAN_PLUS                       (TypeParamBounds(rev(type_param_bounds_expansion)))
                    (* | type_param_bounds_expansion PLUS           (TypeParamBounds(rev(type_param_bounds_expansion))) *)
type_param_bounds_expansion: type_param_bounds_expansion
                            PLUS type_param_bound               (type_param_bound::type_param_bounds_expansion)
                        | type_param_bound                      ([type_param_bound])
type_param_bound: lifetime                                      (LTB(lifetime))
                | trait_bound                                   (TB(trait_bound))

lifetime_bounds: lifetime_bounds_expansion                      (LifetimeBounds(rev(lifetime_bounds_expansion)))
                | lifetime_bounds_expansion lifetime            (LifetimeBounds(lifetime::rev(lifetime_bounds_expansion)))
lifetime_bounds_expansion: lifetime_bounds_expansion
                    lifetime PLUS                               (lifetime::lifetime_bounds_expansion)
                    |                                           (nil)
maybe_lifetime: lifetime                                        (SOME(lifetime))
                |                                               (NONE)

lifetime: (* here are some questions *)
          LIFETIME_OR_LABEL                                     (LifetimeOrLabel(LIFETIME_OR_LABEL))
        | STATICLIFETIME                                        (StaticLifetime)
trait_bound: type_path                                          (TraitBound(NONE, NONE, type_path))
            | for_lifetimes type_path                           (TraitBound(NONE, SOME(for_lifetimes), type_path))
            | QUESTION maybe_for_lifetimes type_path            (TraitBound(SOME(Sized), maybe_for_lifetimes, type_path))
            | LPARENT type_path RPARENT                         (TraitBound(NONE, NONE, type_path))
            | LPARENT for_lifetimes type_path RPARENT           (TraitBound(NONE, SOME(for_lifetimes), type_path))
            | LPARENT QUESTION 
                maybe_for_lifetimes type_path RPARENT           (TraitBound(SOME(Sized), maybe_for_lifetimes, type_path))


self_param: AND SELFVALUE                                       (SelfParamLT (NONE, NonMut))
            | AND MUT SELFVALUE                                 (SelfParamLT (NONE, Mut))
            | AND lifetime maybe_mut SELFVALUE                  (SelfParamLT (SOME(lifetime), maybe_mut))
            | SELFVALUE                                         (SelfParamTY (NonMut, NONE))
            | MUT SELFVALUE                                     (SelfParamTY (Mut, NONE))
            | SELFVALUE COLON types                             (SelfParamTY (NonMut, SOME(types)))
            | MUT SELFVALUE COLON types                         (SelfParamTY (Mut, SOME(types)))

(* 
    In inherent implement, to remove reduce/reduce conflicts in generics and types, 
    requiring users to provide parents delimiter around types.
*)
inherent_impl: IMPL maybe_generics LPARENT types RPARENT maybe_where_clause
                LBRACE inner_attrs inherent_impl_items RBRACE   (InherentImpl ({
                                                                    generic=maybe_generics, ty=types, wh=maybe_where_clause, 
                                                                    innerAttrs=inner_attrs, implItems=inherent_impl_items
                                                                }))
            | IMPL maybe_generics types_noqpt maybe_where_clause
                LBRACE inner_attrs inherent_impl_items RBRACE   (InherentImpl ({
                                                                    generic=maybe_generics, ty=types_noqpt, wh=maybe_where_clause, 
                                                                    innerAttrs=inner_attrs, implItems=inherent_impl_items
                                                                }))
inherent_impl_items: inherent_impl_items inherent_impl_item     (inherent_impl_item::inherent_impl_items)
                    |                                           (nil)
inherent_impl_item: outer_attrs macro_invocation_semi           (InherentImplItemMacro (outer_attrs, macro_invocation_semi))
                    | outer_attrs maybe_visibility 
                        constant_item                           (InherentImplItemType (outer_attrs, maybe_visibility, constant_item))
                    | outer_attrs maybe_visibility function     (InherentImplItemType (outer_attrs, maybe_visibility, function))
                    | outer_attrs maybe_visibility method       (InherentImplItemMethod (outer_attrs, maybe_visibility, method))
trait_impl:  IMPL maybe_generics type_path
            FOR types maybe_where_clause LBRACE
            inner_attrs trait_impl_items RBRACE                 (TraitImpl({
                                                                    unsafe=NONE, generic=maybe_generics, neg=false, typath=type_path, ty=types,
                                                                    wh=maybe_where_clause, innerAttrs=inner_attrs, implItems=trait_impl_items
                                                                }))
            |IMPL maybe_generics NOT type_path
            FOR types maybe_where_clause LBRACE
            inner_attrs trait_impl_items RBRACE                 (TraitImpl({
                                                                    unsafe=NONE, generic=maybe_generics, neg=true, typath=type_path, ty=types,
                                                                    wh=maybe_where_clause, innerAttrs=inner_attrs, implItems=trait_impl_items
                                                                }))
            | UNSAFE IMPL maybe_generics  type_path
            FOR types maybe_where_clause LBRACE
            inner_attrs trait_impl_items RBRACE                 (TraitImpl({
                                                                    unsafe=SOME(Unsafe), generic=maybe_generics, neg=false, typath=type_path, ty=types,
                                                                    wh=maybe_where_clause, innerAttrs=inner_attrs, implItems=trait_impl_items
                                                                }))
            | UNSAFE IMPL maybe_generics NOT type_path
            FOR types maybe_where_clause LBRACE
            inner_attrs trait_impl_items RBRACE                 (TraitImpl({
                                                                    unsafe=SOME(Unsafe), generic=maybe_generics, neg=true, typath=type_path, ty=types,
                                                                    wh=maybe_where_clause, innerAttrs=inner_attrs, implItems=trait_impl_items
                                                                }))
trait_impl_items: trait_impl_items trait_impl_item              (trait_impl_item::trait_impl_items)
                |                                               (nil)
trait_impl_item: outer_attrs macro_invocation_semi              (TraitImplItemMacro (outer_attrs, macro_invocation_semi))
                | outer_attrs maybe_visibility type_alias       (TraitImplItemType (outer_attrs, maybe_visibility, type_alias))
                | outer_attrs maybe_visibility constant_item    (TraitImplItemType (outer_attrs, maybe_visibility, constant_item))
                | outer_attrs maybe_visibility function         (TraitImplItemType (outer_attrs, maybe_visibility, function))
                | outer_attrs maybe_visibility method           (TraitImplItemMethod (outer_attrs, maybe_visibility, method))
method: func_qualifier FN IDENT maybe_generics LPARENT
        self_param func_parameters_expansion maybe_comma RPARENT
        maybe_func_return_type maybe_where_clause 
        block_exp                                               (Method ({
                                                                    qualifier=func_qualifier, name=Identifer(IDENT), generic=maybe_generics, 
                                                                    selfParam=self_param, params=rev(func_parameters_expansion), 
                                                                    ret=maybe_func_return_type, wh=maybe_where_clause, be=block_exp
                                                                }))

extern_block: EXTERN maybe_abi LBRACE inner_attrs
            external_items RBRACE                               (ExternBlock (maybe_abi, inner_attrs, external_items))
external_items: external_items external_item                    (external_item::external_items)
            |                                                   (nil)
external_item: outer_attrs 
                maybe_visibility external_static_item           (ExternalItem (outer_attrs, maybe_visibility, external_static_item))
            | outer_attrs
                maybe_visibility external_func_item             (ExternalItem (outer_attrs, maybe_visibility, external_func_item))
external_static_item: STATIC maybe_mut IDENT COLON types SEMI   (ExternalStaticItem (maybe_mut, Identifer(IDENT), types))
external_func_item: FN IDENT maybe_generics LPARENT
                maybe_named_func_parameters RPARENT
                maybe_func_return_type maybe_where_clause
                SEMI                                            (ExternalFunctionItem ({
                                                                    name=Identifer(IDENT), generic=maybe_generics, 
                                                                    params=maybe_named_func_parameters, ret=maybe_func_return_type, 
                                                                    wh=maybe_where_clause
                                                                }))
            |   FN IDENT maybe_generics LPARENT
                named_func_parameters_with_variadics RPARENT
                maybe_func_return_type maybe_where_clause
                SEMI                                            (ExternalFunctionItem ({
                                                                    name=Identifer(IDENT), generic=maybe_generics, 
                                                                    params=named_func_parameters_with_variadics, ret=maybe_func_return_type, 
                                                                    wh=maybe_where_clause
                                                                }))

maybe_named_func_parameters: named_func_parameters              (named_func_parameters)
                        |                                       (ExternFunctionParameter ({params=[], var=false}))
named_func_parameters: named_func_param 
                named_func_parameters_expansion maybe_comma     (ExternFunctionParameter ({params=named_func_param::rev(named_func_parameters_expansion), var=false}))
named_func_parameters_expansion: 
    named_func_parameters_expansion COMMA named_func_param      (named_func_param::named_func_parameters_expansion)
                    |                                           (nil)
named_func_param: IDENT COLON types                             (NamedFunctionParam (SOME(Identifer(IDENT)), types))
                 | UNDERSCORE COLON types                       (NamedFunctionParam (NONE, types))
named_func_parameters_with_variadics:
                (* For convenient, this production is rewrote *)
                named_func_param named_func_parameters_expansion 
                COMMA DOTDOTDOT                                 (ExternFunctionParameter ({params=named_func_param::rev(named_func_parameters_expansion), var=true}))

(* ------pattern-------- *)
patterns: 
        lit_pat                                                 (yaccLog("patterns:lit_pat"); lit_pat)
        | id_pat                                                (yaccLog("patterns:id_pat"); id_pat)
        | wildcard_pat                                          (yaccLog("patterns:wildcard_pat"); wildcard_pat)
        | range_pat                                             (yaccLog("patterns:range_pat"); range_pat)
        | reference_pat                                         (yaccLog("patterns:reference_pat"); reference_pat)
        | struct_pat                                            (yaccLog("patterns:struct_pat"); struct_pat)
        | tuple_struct_pat                                      (yaccLog("patterns:tuple_struct_pat"); tuple_struct_pat)
        | tuple_or_grouped_pat                                  (yaccLog("patterns:tuple_or_grouped_pat"); tuple_or_grouped_pat)
        | LPARENT RPARENT                                       (yaccLog("patterns:unit"); TupleORGroupPattern([], Pos(LPARENTleft)))
        (* tuple pattern contains group pattern *)
        (* | grouped_pat                                           (Pattern) *)
        | slice_pat                                             (yaccLog("patterns:slice_pat"); slice_pat)
        | path_pat                                              (yaccLog("patterns:path_pat"); path_pat)

lit_pat: TRUE                                                   (LiteralPattern(NONE, TKTRUE(Pos(TRUEleft)), Pos(TRUEleft)))
        | FALSE                                                 (LiteralPattern(NONE, TKFALSE(Pos(FALSEleft)), Pos(FALSEleft)))
        | CHAR_LIT                                              (LiteralPattern(NONE, TKCHAR_LIT(CHAR_LIT, Pos(CHAR_LITleft)), Pos(CHAR_LITleft)))
        | BYTE_LIT                                              (LiteralPattern(NONE, TKBYTE_LIT(BYTE_LIT, Pos(BYTE_LITleft)), Pos(BYTE_LITleft)))
        | STR_LIT                                               (LiteralPattern(NONE, TKSTR_LIT(STR_LIT, Pos(STR_LITleft)), Pos(STR_LITleft)))
        | RAW_STR_LIT                                           (LiteralPattern(NONE, TKRAW_STR_LIT(RAW_STR_LIT, Pos(RAW_STR_LITleft)), Pos(RAW_STR_LITleft)))
        | BYTE_STR_LIT                                          (LiteralPattern(NONE, TKBYTE_STR_LIT(BYTE_STR_LIT, Pos(BYTE_STR_LITleft)), Pos(BYTE_STR_LITleft)))
        | RAW_BYTE_STR_LIT                                      (LiteralPattern(NONE, TKRAW_BYTE_STR_LIT(RAW_BYTE_STR_LIT, Pos(RAW_BYTE_STR_LITleft)), Pos(RAW_BYTE_STR_LITleft)))
        | INTEGER_LIT                                           (LiteralPattern(NONE, TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(INTEGER_LITleft)))
        | MINUS INTEGER_LIT                                     (LiteralPattern(SOME(Minus(Pos(MINUSleft))), TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(INTEGER_LITleft)))
        | FLOAT_LIT                                             (LiteralPattern(NONE, TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft)), Pos(FLOAT_LITleft)))
        | MINUS FLOAT_LIT                                       (LiteralPattern(SOME(Minus(Pos(MINUSleft))), TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft)), Pos(FLOAT_LITleft)))

id_pat: 
        (* path pattern contains Identifer *)
        (* IDENT                                                   () *)
        binding_mode IDENT                                      (IdentiferPattern(binding_mode, Identifer(IDENT), NONE))
        | IDENT AT patterns                                     (IdentiferPattern(BindingMode(NONE, NonMut, Pos(IDENTleft)), Identifer(IDENT), NONE))
        | binding_mode IDENT AT patterns                        (IdentiferPattern(binding_mode, Identifer(IDENT), NONE))

binding_mode: REF                                               (BindingMode(SOME(Ref(Pos(REFleft))), NonMut, Pos(REFleft)))
            | REF MUT                                           (BindingMode(SOME(Ref(Pos(REFleft))), Mut, Pos(REFleft)))
            | MUT                                               (BindingMode(NONE, Mut, Pos(MUTleft)))

wildcard_pat: UNDERSCORE                                        (WildcardPattern(Pos(UNDERSCOREleft)))

range_pat: range_pat_bound DOTDOTEQ range_pat_bound             (RangePatternDDE(range_pat_bound1, range_pat_bound2))
            | range_pat_bound DOTDOTDOT range_pat_bound         (RangePatternDDD(range_pat_bound1, range_pat_bound2))
range_pat_bound: CHAR_LIT                                       (RPBLit(NONE, TKCHAR_LIT(CHAR_LIT, Pos(CHAR_LITleft)), Pos(CHAR_LITleft)))
                | BYTE_LIT                                      (RPBLit(NONE, TKBYTE_LIT(BYTE_LIT, Pos(BYTE_LITleft)), Pos(BYTE_LITleft)))
                | INTEGER_LIT                                   (RPBLit(NONE, TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(INTEGER_LITleft)))
                | MINUS INTEGER_LIT                             (RPBLit(SOME(Minus(Pos(MINUSleft))), TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(INTEGER_LITleft)))
                | FLOAT_LIT                                     (RPBLit(NONE, TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft)), Pos(FLOAT_LITleft)))
                | MINUS FLOAT_LIT                               (RPBLit(SOME(Minus(Pos(MINUSleft))), TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft)), Pos(FLOAT_LITleft)))
                | path_in_exp                                   (RPBPath(path_in_exp))
                | qualified_path_in_exp                         (RPBQPath(qualified_path_in_exp))

reference_pat: AND  patterns                                    (ReferencePattern(BOnce(Pos(ANDleft)), NonMut, patterns, Pos(ANDleft)))
            | ANDAND  patterns                                  (ReferencePattern(BTwice(Pos(ANDANDleft)), NonMut, patterns, Pos(ANDANDleft)))
            | AND MUT patterns                                  (ReferencePattern(BOnce(Pos(ANDleft)), Mut, patterns, Pos(ANDleft)))
            | ANDAND MUT patterns                               (ReferencePattern(BTwice(Pos(ANDANDleft)), Mut, patterns, Pos(ANDANDleft)))

struct_pat: path_in_exp LBRACE RBRACE                           (StructPattern(path_in_exp, StructPatternElements([], NONE)))
            | path_in_exp LBRACE struct_pat_elements RBRACE     (StructPattern(path_in_exp, struct_pat_elements))
struct_pat_elements: struct_pat_etcetera                        (StructPatternElements([], SOME(struct_pat_etcetera)))
                    | struct_pat_fields COMMA                   (StructPatternElements(rev(struct_pat_fields), NONE))
                    | struct_pat_fields 
                        COMMA struct_pat_etcetera               (StructPatternElements(rev(struct_pat_fields), SOME(struct_pat_etcetera)))
                    | struct_pat_fields                         (StructPatternElements(rev(struct_pat_fields), NONE))
struct_pat_fields: struct_pat_fields COMMA struct_pat_field     (struct_pat_field::struct_pat_fields)
                    | struct_pat_field                          ([struct_pat_field])
struct_pat_field: outer_attrs INTEGER_LIT COLON patterns        (SPFTPIND(outer_attrs, TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)), patterns, Pos(INTEGER_LITleft)))
                | outer_attrs IDENT COLON patterns              (SPFIBD(outer_attrs, Identifer(IDENT), patterns, Pos(IDENTleft)))
                | outer_attrs IDENT                             (SPFID(outer_attrs, NONE, NonMut, Identifer(IDENT), Pos(IDENTleft)))
                | outer_attrs REF IDENT                         (SPFID(outer_attrs, SOME(Ref(Pos(REFleft))), NonMut, Identifer(IDENT), Pos(REFleft)))
                | outer_attrs REF MUT IDENT                     (SPFID(outer_attrs, SOME(Ref(Pos(REFleft))), Mut, Identifer(IDENT), Pos(REFleft)))
                | outer_attrs MUT IDENT                         (SPFID(outer_attrs, NONE, Mut, Identifer(IDENT), Pos(IDENTleft)))
struct_pat_etcetera: outer_attrs DOTDOT                         (StructPatternEtCetera(outer_attrs, Pos(DOTDOTleft)))

tuple_struct_pat: path_in_exp 
                LPARENT tuple_pat_items RPARENT                 (TupleStructPattern(path_in_exp, rev(tuple_pat_items)))
                | path_in_exp 
                LPARENT tuple_pat_items COMMA RPARENT           (TupleStructPattern(path_in_exp, rev(tuple_pat_items)))
                | path_in_exp 
                LPARENT DOTDOT RPARENT                          (TupleStructPatternDD(path_in_exp, [], []))
                | path_in_exp 
                LPARENT tuple_pat_items COMMA DOTDOT RPARENT    (TupleStructPatternDD(path_in_exp, rev(tuple_pat_items), []))
                | path_in_exp 
                    LPARENT DOTDOT 
                    COMMA tuple_pat_items maybe_comma RPARENT   (TupleStructPatternDD(path_in_exp, [], rev(tuple_pat_items)))
                | path_in_exp 
                    LPARENT tuple_pat_items COMMA DOTDOT
                    COMMA tuple_pat_items maybe_comma RPARENT   (TupleStructPatternDD(path_in_exp, rev(tuple_pat_items1), rev(tuple_pat_items2)))

tuple_or_grouped_pat: LPARENT tuple_pat_items RPARENT           (TupleORGroupPattern(rev(tuple_pat_items), Pos(LPARENTleft)))
            | LPARENT tuple_pat_items COMMA RPARENT             (TupleORGroupPattern(rev(tuple_pat_items), Pos(LPARENTleft)))
            | LPARENT DOTDOT RPARENT                            (TupleORGroupPatternDD([], [], Pos(LPARENTleft)))
            | LPARENT tuple_pat_items COMMA DOTDOT RPARENT      (TupleORGroupPatternDD(rev(tuple_pat_items), [], Pos(LPARENTleft)))
            | LPARENT DOTDOT 
                COMMA tuple_pat_items maybe_comma RPARENT       (TupleORGroupPatternDD([], rev(tuple_pat_items), Pos(LPARENTleft)))
            | LPARENT tuple_pat_items COMMA DOTDOT 
                COMMA tuple_pat_items maybe_comma RPARENT       (TupleORGroupPatternDD(rev(tuple_pat_items1), rev(tuple_pat_items2), Pos(LPARENTleft)))
tuple_pat_items: tuple_pat_items COMMA patterns                 (patterns::tuple_pat_items)
                | patterns                                      ([patterns])

slice_pat: LBRACKET tuple_pat_items maybe_comma RBRACKET        (SlicePattern(rev(tuple_pat_items), Pos(LBRACKETleft)))

path_pat: path_in_exp                                           (PathPat(path_in_exp))
        | qualified_path_in_exp                                 (QPathPat(qualified_path_in_exp))

(* ------Type------ *)
types: type_no_bounds                                           (TypeNoBoundsT(type_no_bounds))
        | IMPL lifetime                                         (ImplTraitType(TypeParamBounds([LTB(lifetime)]), Pos(IMPLleft)))
        | IMPL trait_bound PLUS type_param_bounds               (ImplTraitType(
                                                                    TypeParamBounds(rev(TB(trait_bound)::((fn TypeParamBounds(lst) => rev(lst)) type_param_bounds))), 
                                                                    Pos(IMPLleft)
                                                                ))
        | DYN lifetime                                          (TraitObjectType(TypeParamBounds([LTB(lifetime)]), Pos(DYNleft)))
        | DYN trait_bound PLUS type_param_bounds                (TraitObjectType(
                                                                    TypeParamBounds(rev(TB(trait_bound)::((fn TypeParamBounds(lst) => rev(lst)) type_param_bounds))), 
                                                                    Pos(DYNleft)
                                                                ))
type_no_bounds: 
                LPARENT types RPARENT %prec LPARENT             (ParenthesizedType(types, Pos(LPARENTleft)))
                (* ImplTraitType contains Impl TraitTypeOneBound  *)
                | IMPL trait_bound %prec LOWER_THAN_PLUS        (ImplTraitTypeOneBound(trait_bound, Pos(IMPLleft)))
                (* 
                    Trait Object Type One Bound production must 
                    have keyword dyn for avoiding conflicts. 
                *)
                (* TraitObjectType contains Impl TraitObjectTypeOneBound   *)
                | DYN trait_bound %prec LOWER_THAN_PLUS         (TraitObjectTypeOneBound(trait_bound, Pos(DYNleft)))
                (* trait_bound contains LPARENT type_path RPARENT *)
                (* | trait_bound                                   () *)
                | type_path %prec LOWER_THAN_PATHSEP            (TNBTypePath(type_path))
                | LPARENT RPARENT                               (TupleType([], Pos(LPARENTleft)))
                | LPARENT types COMMA 
                    types_expansion maybe_comma RPARENT         (TupleType(rev(types::types_expansion), Pos(LPARENTleft)))
                | NOT                                           (NeverTuple(Pos(NOTleft)))
                | STAR MUT type_no_bounds                       (RawPointerType(MutMod(Pos(MUTleft)), type_no_bounds, Pos(STARleft)))
                | STAR CONST type_no_bounds                     (RawPointerType(ConstMod(Pos(CONSTleft)), type_no_bounds, Pos(STARleft)))
                | AND maybe_lifetime maybe_mut type_no_bounds   (ReferenceType(maybe_lifetime, maybe_mut, type_no_bounds, Pos(ANDleft)))
                | LBRACKET types SEMI expression RBRACKET       (ArrayType(types, expression, Pos(LBRACKETleft)))
                | LBRACKET types RBRACKET                       (SliceType(types, Pos(LBRACKETleft)))
                | UNDERSCORE                                    (InferredType(Pos(UNDERSCOREleft)))  
                | qualified_path_in_type                        (TNBQPathInType(qualified_path_in_type))
                | maybe_for_lifetimes 
                    func_qualifier FN LPARENT RPARENT           (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=[], var=false, ret=NONE
                                                                }))
                |  maybe_for_lifetimes 
                    func_qualifier FN LPARENT 
                    maybe_named_bare_func_parameters maybe_comma 
                    RPARENT                                     (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters), var=false, ret=NONE
                                                                }))
                |  maybe_for_lifetimes 
                    func_qualifier FN LPARENT 
                    maybe_named_bare_func_parameters_variadic 
                    RPARENT                                     (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters_variadic), 
                                                                    var=true, ret=NONE
                                                                }))
                | maybe_for_lifetimes 
                    func_qualifier FN LPARENT RPARENT 
                    RARROW type_no_bounds                       (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=[], var=false, ret=SOME(type_no_bounds)
                                                                }))
                |  maybe_for_lifetimes 
                    func_qualifier FN LPARENT 
                    maybe_named_bare_func_parameters maybe_comma 
                    RPARENT RARROW type_no_bounds               (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters),
                                                                    var=false, ret=SOME(type_no_bounds)
                                                                }))
                |  maybe_for_lifetimes 
                    func_qualifier FN LPARENT 
                    maybe_named_bare_func_parameters_variadic 
                    RPARENT                                     
                    RARROW type_no_bounds                       (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters_variadic),
                                                                    var=true, ret=SOME(type_no_bounds)
                                                                }))
                (* | macro_invocation                              () *)
                (* TypePath contains PathInExpression, 
                rewrite MarcoInvocation for avoiding conflicts, 
                maybe need to check TypePathFn. *)
                | type_path NOT delim_token_tree              (TNBMacro(type_path, delim_token_tree))
                (* | macro_invocation                              () *)
types_expansion: types_expansion COMMA types                    (types::types_expansion)
                | types                                         ([types])                
maybe_named_bare_func_parameters: 
                maybe_named_bare_func_parameters 
                COMMA maybe_named_param                         (maybe_named_param::maybe_named_bare_func_parameters)
                | maybe_named_param                             ([maybe_named_param])
maybe_named_bare_func_parameters_variadic: 
            maybe_named_bare_func_parameters COMMA DOTDOTDOT    (maybe_named_bare_func_parameters)
maybe_named_param: types                                        (MaybeNamedParamTY(types))
                | IDENT COLON types                             (MaybeNamedParamID(Identifer(IDENT), types, Pos(IDENTleft)))
                | UNDERSCORE COLON types                        (MaybeNamedParamWD(Wildcard(Pos(UNDERSCOREleft)), types, Pos(UNDERSCOREleft)))

types_noqpt:
        types_noqpt_no_bounds                                   (TypeNoBoundsT(types_noqpt_no_bounds))
        | IMPL lifetime                                         (ImplTraitType(TypeParamBounds([LTB(lifetime)]), Pos(IMPLleft)))
        | IMPL trait_bound PLUS type_param_bounds               (ImplTraitType(
                                                                    TypeParamBounds(rev(TB(trait_bound)::((fn TypeParamBounds(lst) => rev(lst)) type_param_bounds))), 
                                                                    Pos(IMPLleft)
                                                                ))
        | DYN lifetime                                          (TraitObjectType(TypeParamBounds([LTB(lifetime)]), Pos(DYNleft)))
        | DYN trait_bound PLUS type_param_bounds                (TraitObjectType(
                                                                    TypeParamBounds(rev(TB(trait_bound)::((fn TypeParamBounds(lst) => rev(lst)) type_param_bounds))), 
                                                                    Pos(DYNleft)
                                                                ))
types_noqpt_no_bounds: 
        (* ImplTraitType contains Impl TraitTypeOneBound  *)
        IMPL trait_bound %prec LOWER_THAN_PLUS                  (ImplTraitTypeOneBound(trait_bound, Pos(IMPLleft)))
        (* 
            Trait Object Type One Bound production must 
            have keyword dyn for avoiding conflicts. 
        *)
        (* TraitObjectType contains Impl TraitObjectTypeOneBound   *)
        | DYN trait_bound %prec LOWER_THAN_PLUS                 (TraitObjectTypeOneBound(trait_bound, Pos(DYNleft)))
        (* trait_bound contains LPARENT type_path RPARENT *)
        (* | trait_bound                                   () *)
        | type_path %prec LOWER_THAN_PATHSEP                    (TNBTypePath(type_path))
        | LPARENT RPARENT                                       (TupleType([], Pos(LPARENTleft)))
        | LPARENT types COMMA 
            types_expansion maybe_comma RPARENT                 (TupleType(rev(types::types_expansion), Pos(LPARENTleft)))
        | NOT                                                   (NeverTuple(Pos(NOTleft)))
        | STAR MUT type_no_bounds                               (RawPointerType(MutMod(Pos(MUTleft)), type_no_bounds, Pos(STARleft)))
        | STAR CONST type_no_bounds                             (RawPointerType(ConstMod(Pos(CONSTleft)), type_no_bounds, Pos(STARleft)))
        | AND maybe_lifetime maybe_mut type_no_bounds           (ReferenceType(maybe_lifetime, maybe_mut, type_no_bounds, Pos(ANDleft)))
        | LBRACKET types SEMI expression RBRACKET               (ArrayType(types, expression, Pos(LBRACKETleft)))
        | LBRACKET types RBRACKET                               (SliceType(types, Pos(LBRACKETleft)))
        | UNDERSCORE                                            (InferredType(Pos(UNDERSCOREleft)))  
        | maybe_for_lifetimes 
            func_qualifier FN LPARENT RPARENT                   (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=[], var=false, ret=NONE
                                                                }))
        |  maybe_for_lifetimes 
            func_qualifier FN LPARENT 
            maybe_named_bare_func_parameters maybe_comma 
            RPARENT                                             (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters), var=false, ret=NONE
                                                                }))
        |  maybe_for_lifetimes 
            func_qualifier FN LPARENT 
            maybe_named_bare_func_parameters_variadic 
            RPARENT                                             (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters_variadic), 
                                                                    var=true, ret=NONE
                                                                }))
        | maybe_for_lifetimes 
            func_qualifier FN LPARENT RPARENT 
            RARROW type_no_bounds                               (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=[], var=false, ret=SOME(type_no_bounds)
                                                                }))
        |  maybe_for_lifetimes 
            func_qualifier FN LPARENT 
            maybe_named_bare_func_parameters maybe_comma 
            RPARENT RARROW type_no_bounds                       (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters),
                                                                    var=false, ret=SOME(type_no_bounds)
                                                                }))
        |  maybe_for_lifetimes 
            func_qualifier FN LPARENT 
            maybe_named_bare_func_parameters_variadic 
            RPARENT                                     
            RARROW type_no_bounds                               (BareFunctionType({
                                                                    forlifetimes=maybe_for_lifetimes, qualifier=func_qualifier, 
                                                                    params=rev(maybe_named_bare_func_parameters_variadic),
                                                                    var=true, ret=SOME(type_no_bounds)
                                                                }))
        (* | macro_invocation                              () *)
        (* TypePath contains PathInExpression, 
        rewrite MarcoInvocation for avoiding conflicts, 
        maybe need to check TypePathFn. *)
        | type_path NOT delim_token_tree                    (TNBMacro(type_path, delim_token_tree))
    
(* ------Statements and Expression------ *)
block_exp: LBRACE inner_attrs RBRACE                            (BlockExpr(inner_attrs, [], Pos(LBRACEleft)))
        | LBRACE inner_attrs statements RBRACE                  (BlockExpr(inner_attrs, statements, Pos(LBRACEleft)))
(* statements: statements_expansion                                ()
            | statements_expansion exp_without_block            ()
            | exp_without_block                                 () *)
statements: statements_expansion                                (rev(statements_expansion))
            | statements_expansion noblock_exp                  (rev(STMTExpression(noblock_exp)::statements_expansion))
            | noblock_exp                                       ([STMTExpression(noblock_exp)])
statements_expansion: statements_expansion statement            (statement::statements_expansion)
                    | statement                                 ([statement])
(* statement: (* need to be completed *)
            SEMI                                                ()
            (* Use "vis_item" replace "item" for avoiding conflicts. *)
            (* | item                                              () *)
            | outer_attrs vis_item                              ()
            | let_statement                                     ()
            | exp_statement                                     ()
            (* item contain macro item *)
            | macro_invocation_semi                             () *)
statement:  SEMI                                                (STMTSemi)
            | let_statement                                     (STMLet(let_statement))
            (* | macro_invocation_semi                             () *)
            | outer_attrs vis_item                              (STMTItem(VisItemType(outer_attrs, vis_item)))
            | full_block_exp                                    (STMTExpression(full_block_exp))
            | noblock_exp SEMI                                  (STMTExpression(noblock_exp))
let_statement: outer_attrs LET patterns SEMI                    (LetStatement(outer_attrs, patterns, NONE, NONE, Pos(LETleft)))
            | outer_attrs LET patterns COLON types SEMI         (LetStatement(outer_attrs, patterns, SOME(types), NONE, Pos(LETleft)))
            | outer_attrs LET patterns EQ expression SEMI       (LetStatement(outer_attrs, patterns, NONE, SOME(expression), Pos(LETleft)))
            | outer_attrs LET patterns 
                COLON types EQ expression SEMI                  (LetStatement(outer_attrs, patterns, SOME(types), SOME(expression), Pos(LETleft)))

(* exp_statement: exp_without_block SEMI                           ()
            | exp_with_block                                    () *)
expression: exp_without_block                                   (exp_without_block)
            | exp_with_block                                    (exp_with_block)

exp_without_block: (* outer_attrs before exp *)
                 lit_exp                                        (lit_exp)
                | path_in_exp %prec IDENT                       (PathExpr(path_in_exp))
                | qualified_path_in_exp %prec IDENT             (QPathExpr(qualified_path_in_exp))
                | op_exp                                        (op_exp)
                | grouped_exp                                   (grouped_exp)
                | array_exp                                     (array_exp)
                | index_exp                                     (index_exp)
                | tuple_exp                                     (tuple_exp)
                | tuple_index_exp                               (tuple_index_exp)
                | struct_exp                                    (struct_exp)
                (* struct exp contains enum *)
                (* | enum_var_exp                                  () *)
                | call_exp                                      (call_exp)
                | method_call_exp                               (method_call_exp)
                | field_exp                                     (field_exp)
                | closure_exp                                   (closure_exp)
                | continue_exp                                  (continue_exp)
                | break_exp                                     (break_exp)
                | range_exp                                     (range_exp)
                | return_exp                                    (return_exp)
                (* macro_invocation_semi contains macro_invocation *)
                | macro_invocation                              (MacroExpr(macro_invocation))

lit_exp: str_lit                                                (LiteralExpr(str_lit))
        | bool_lit                                              (LiteralExpr(bool_lit))
        | CHAR_LIT                                              (LiteralExpr(TKCHAR_LIT(CHAR_LIT, Pos(CHAR_LITleft))))
        | BYTE_LIT                                              (LiteralExpr(TKBYTE_LIT(BYTE_LIT, Pos(BYTE_LITleft))))
        | INTEGER_LIT                                           (LiteralExpr(TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft))))
        | FLOAT_LIT                                             (LiteralExpr(TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft))))
bool_lit: TRUE                                                  (TKTRUE(Pos(TRUEleft)))
        | FALSE                                                 (TKFALSE(Pos(FALSEleft)))
str_lit: STR_LIT                                                (TKSTR_LIT(STR_LIT, Pos(STR_LITleft)))
        | RAW_STR_LIT                                           (TKRAW_STR_LIT(RAW_STR_LIT, Pos(RAW_STR_LITleft)))
        | BYTE_STR_LIT                                          (TKBYTE_STR_LIT(BYTE_STR_LIT, Pos(BYTE_STR_LITleft)))
        | RAW_BYTE_STR_LIT                                      (TKRAW_BYTE_STR_LIT(RAW_BYTE_STR_LIT, Pos(RAW_BYTE_STR_LITleft)))


op_exp: (* borrow expression*)
        AND expression                                          (BorrowExpr(BOnce(Pos(ANDleft)), NonMut, expression, Pos(ANDleft)))
        | ANDAND expression                                     (BorrowExpr(BTwice(Pos(ANDANDleft)), NonMut, expression, Pos(ANDANDleft)))
        | AND MUT expression                                    (BorrowExpr(BOnce(Pos(ANDleft)), Mut, expression, Pos(ANDleft)))
        | ANDAND MUT expression                                 (BorrowExpr(BTwice(Pos(ANDANDleft)), Mut, expression, Pos(ANDANDleft)))
        (* dereference expression*)
        | STAR expression                                       (DereferenceExpr(expression, Pos(STARleft)))
        (* question mark operator *)
        | expression QUESTION                                   (ErrorPropagationExpr(expression, Pos(QUESTIONleft)))
        (* negation expression *)
        | MINUS expression                                      (NegExpr(expression, Pos(MINUSleft)))
        | NOT expression                                        (NotExpr(expression, Pos(NOTleft)))
        (* arithmetic or logical expression *)
        | expression PLUS expression                            (ArithmeticOrLogicalExpr(expression1, AddOp, expression2, Pos(PLUSleft)))
        | expression MINUS expression                           (ArithmeticOrLogicalExpr(expression1, SubOp, expression2, Pos(MINUSleft)))
        | expression STAR expression                            (ArithmeticOrLogicalExpr(expression1, MultOp, expression2, Pos(STARleft)))
        | expression SLASH expression                           (ArithmeticOrLogicalExpr(expression1, DiviOp, expression2, Pos(SLASHleft)))
        | expression PERCENT expression                         (ArithmeticOrLogicalExpr(expression1, RemainderOp, expression2, Pos(PERCENTleft)))
        | expression AND expression                             (ArithmeticOrLogicalExpr(expression1, AndOp, expression2, Pos(ANDleft)))
        | expression OR expression                              (ArithmeticOrLogicalExpr(expression1, OrOp, expression2, Pos(ORleft)))
        | expression CARET expression                           (ArithmeticOrLogicalExpr(expression1, XorOp, expression2, Pos(CARETleft)))
        | expression SHL expression                             (ArithmeticOrLogicalExpr(expression1, LShiftOp, expression2, Pos(SHLleft)))
        | expression shr expression %prec SHR                   (ArithmeticOrLogicalExpr(expression1, RShiftOp, expression2, Pos(shr)))
        (* comparision expression  *)
        | expression EQEQ expression                            (ComparisonExpr(expression1, EqOp, expression2, Pos(EQEQleft)))
        | expression NE expression                              (ComparisonExpr(expression1, NeqOp, expression2, Pos(NEleft)))
        | expression GT expression                              (ComparisonExpr(expression1, GtOp, expression2, Pos(GTleft)))
        | expression LT expression                              (ComparisonExpr(expression1, LtOp, expression2, Pos(LTleft)))
        | expression ge expression %prec GE                     (ComparisonExpr(expression1, GeOp, expression2, Pos(ge)))
        | expression LE expression                              (ComparisonExpr(expression1, LeOp, expression2, Pos(LEleft)))
        (* lazy boolean expression *)
        | expression OROR expression                            (LazyBooleanExpr(expression1, LazyOrOp,expression2, Pos(ORORleft)))
        | expression ANDAND expression                          (LazyBooleanExpr(expression1, LazyAndOp,expression2, Pos(ANDANDleft)))
        (* type case expression *)
        | expression AS type_no_bounds                          (TypeCastExpr(expression, type_no_bounds, Pos(ASleft)))
        (* assignment expression *)
        | expression EQ expression                              (AssignmentExpr(expression1, expression2, Pos(EQleft)))
        (* compound assignment expression *)
        | expression PLUSEQ expression                          (CompoundAssignmentExpr(expression1, AddEqOp,expression2, Pos(PLUSEQleft)))
        | expression MINUSEQ expression                         (CompoundAssignmentExpr(expression1, SubEqOp,expression2, Pos(MINUSEQleft)))
        | expression STAREQ expression                          (CompoundAssignmentExpr(expression1, MultEqOp,expression2, Pos(STAREQleft)))
        | expression SLASHEQ expression                         (CompoundAssignmentExpr(expression1, DiviEqOp,expression2, Pos(SLASHEQleft)))
        | expression PERCENTEQ expression                       (CompoundAssignmentExpr(expression1, RemainderEqOp,expression2, Pos(PERCENTEQleft)))
        | expression ANDEQ expression                           (CompoundAssignmentExpr(expression1, AndEqOp,expression2, Pos(ANDEQleft)))
        | expression OREQ expression                            (CompoundAssignmentExpr(expression1, OrEqOp,expression2, Pos(OREQleft)))
        | expression CARETEQ expression                         (CompoundAssignmentExpr(expression1, XorEqOp,expression2, Pos(CARETEQleft)))
        | expression SHLEQ expression                           (CompoundAssignmentExpr(expression1, LShiftEqOp,expression2, Pos(SHLEQleft)))
        | expression shreq expression %prec SHREQ               (CompoundAssignmentExpr(expression1, RShiftEqOp,expression2, Pos(shreq)))

grouped_exp: LPARENT inner_attrs expression RPARENT             (GroupedExpr(inner_attrs, expression, Pos(LPARENTleft)))

array_exp: LBRACKET inner_attrs RBRACKET                        (ArrayExpr(inner_attrs, [], Pos(LBRACKETleft)))
        | LBRACKET inner_attrs 
            expression SEMI expression RBRACKET                 (ArrayInitExpr(inner_attrs, expression1, expression2, Pos(LBRACKETleft)))
        | LBRACKET inner_attrs 
            array_elements maybe_comma  RBRACKET                (ArrayExpr(inner_attrs, rev(array_elements), Pos(LBRACKETleft)))
array_elements: array_elements COMMA expression                 (expression::array_elements)
                | expression                                    ([expression]) 

index_exp: expression LBRACKET expression RBRACKET              (IndexExpr(expression1, expression2, Pos(LBRACKETleft)))

tuple_exp: LPARENT inner_attrs RPARENT                          (TupleExpr(inner_attrs, [], Pos(LPARENTleft)))
            | LPARENT inner_attrs tuple_elements RPARENT        (TupleExpr(inner_attrs, tuple_elements, Pos(LPARENTleft)))
tuple_elements: tuple_elements_expansion                        (rev(tuple_elements_expansion))
            | tuple_elements_expansion expression               (rev(expression::tuple_elements_expansion))
tuple_elements_expansion: tuple_elements_expansion 
                        expression COMMA                        (expression::tuple_elements_expansion)
                        | expression COMMA                      ([expression])

tuple_index_exp: expression DOT INTEGER_LIT                     (TupleIndexingExpr(expression, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))

struct_exp: struct_exp_struct                                   (struct_exp_struct)
            (* | struct_exp_tuple                                  () *)
            (* path_in_exp is ambigous with path exp *)
            (* | struct_exp_unit                                   () *)
struct_exp_struct: 
                path_in_exp LBRACE inner_attrs RBRACE           (StructOrEnumExpr(path_in_exp, inner_attrs, [], NONE))
                | path_in_exp LBRACE inner_attrs 
                    struct_exp_fields RBRACE                    (StructOrEnumExpr(path_in_exp, inner_attrs, rev(struct_exp_fields), NONE))  
                | path_in_exp LBRACE inner_attrs 
                    struct_exp_fields COMMA RBRACE              (StructOrEnumExpr(path_in_exp, inner_attrs, rev(struct_exp_fields), NONE))              
                | path_in_exp LBRACE inner_attrs 
                    struct_base RBRACE                          (StructOrEnumExpr(path_in_exp, inner_attrs, [], SOME(struct_base)))
                | path_in_exp LBRACE inner_attrs 
                    struct_exp_fields COMMA struct_base RBRACE  (StructOrEnumExpr(path_in_exp, inner_attrs, rev(struct_exp_fields), SOME(struct_base)))
struct_exp_fields: struct_exp_fields
                    COMMA struct_exp_field                      (struct_exp_field::struct_exp_fields)
                    | struct_exp_field                          ([struct_exp_field])
struct_exp_field: IDENT                                         (StructOrEnumExprFieldID(Identifer(IDENT), Pos(IDENTleft)))
                | IDENT COLON expression                        (StructOrEnumExprFieldBD(Identifer(IDENT), expression, Pos(IDENTleft)))
                | INTEGER_LIT COLON expression                  (StructOrEnumExprFieldTI(TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), expression, Pos(INTEGER_LITleft)))
struct_base: DOTDOT expression                                  (StructBase (expression, Pos(DOTDOTleft)))
(* struct_exp_tuple: path_in_exp 
            LPARENT inner_attrs expressions RPARENT             ()
            | path_in_exp 
            LPARENT inner_attrs expressions COMMA RPARENT       () *)
expressions: expressions COMMA expression                       (expression::expressions)
            | expression                                        ([expression])
(* struct_exp_unit: path_in_exp                                    () *)

call_exp: expression LPARENT RPARENT                            (CallExpr(expression, [], Pos(LPARENTleft)))
        | expression LPARENT call_params RPARENT                (CallExpr(expression, call_params, Pos(LPARENTleft)))
call_params: call_params_expansion                              (rev(call_params_expansion))
            | call_params_expansion COMMA                       (rev(call_params_expansion))
call_params_expansion: call_params_expansion COMMA expression   (expression::call_params_expansion)
                    | expression                                ([expression])

(* method_call_exp: expression DOT path_exp_segment LPARENT RPARENT 
                    %prec LPARENT                               ()
                | expression DOT path_exp_segment LPARENT
                    call_params RPARENT  
                    %prec LPARENT                               () *)

method_call_exp: expression DOT IDENT LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [IDPS(Identifer(IDENT))], maybe_call_params))
                | expression DOT SUPER LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [SuperPS], maybe_call_params))
                | expression DOT SELFVALUE LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [SelfValuePS], maybe_call_params))
                | expression DOT SELFTYPE LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [SelfTypePS], maybe_call_params))
                | expression DOT CRATE LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [CratePS], maybe_call_params))
                | expression DOT DOLLAR CRATE LPARENT
                    maybe_call_params RPARENT                   (MethodCallExpr(expression, [DCratePS], maybe_call_params))
                | expression DOT IDENT PATHSEP generic_args
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [IDPS(Identifer(IDENT)), GenericPS(generic_args)], maybe_call_params))
                | expression DOT SUPER PATHSEP generic_args
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [SuperPS, GenericPS(generic_args)], maybe_call_params))
                | expression DOT SELFVALUE PATHSEP generic_args 
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [SelfValuePS, GenericPS(generic_args)], maybe_call_params))
                | expression DOT SELFTYPE PATHSEP generic_args
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [SelfTypePS, GenericPS(generic_args)], maybe_call_params))
                | expression DOT CRATE PATHSEP generic_args
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [CratePS, GenericPS(generic_args)], maybe_call_params))
                | expression DOT DOLLAR CRATE PATHSEP generic_args 
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(expression, [DCratePS, GenericPS(generic_args)], maybe_call_params))

maybe_call_params: call_params                                  (call_params)
                |                                               ([])

field_exp: expression DOT IDENT                                 (FieldExpr(expression, [IDPS(Identifer(IDENT))], Pos(DOTleft)))

closure_exp: OROR expression                                    (ClosureExpr(NONE, [], NONE, expression, Pos(ORORleft)))
            | OROR RARROW type_no_bounds block_exp              (ClosureExpr(NONE, [], SOME(type_no_bounds), block_exp, Pos(ORORleft)))
            | MOVE OROR expression                              (ClosureExpr(SOME(Move), [], NONE, expression, Pos(MOVEleft)))
            | MOVE OROR RARROW type_no_bounds block_exp         (ClosureExpr(SOME(Move), [], SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | OR closure_parameters OR expression               (ClosureExpr(NONE, closure_parameters, NONE, expression, Pos(ORleft)))
            | OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(NONE, closure_parameters, SOME(type_no_bounds), block_exp, Pos(ORleft)))
            | MOVE OR closure_parameters OR expression          (ClosureExpr(SOME(Move), closure_parameters, NONE, expression, Pos(MOVEleft)))
            | MOVE OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(SOME(Move), closure_parameters, SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
closure_parameters: closure_param closure_parameters_expansion  (rev(closure_param::rev(closure_parameters_expansion)))
                    | closure_param 
                        closure_parameters_expansion COMMA      (rev(closure_param::rev(closure_parameters_expansion)))
closure_parameters_expansion: closure_parameters_expansion 
                            COMMA closure_param                 (closure_param::closure_parameters_expansion)
                            |                                   (nil)
closure_param: patterns                                         (ClosureParam(patterns, NONE))
                | patterns COLON types                          (ClosureParam(patterns, SOME(types)))

continue_exp: CONTINUE                                          (ContinueExpr(NONE, Pos(CONTINUEleft)))
            | CONTINUE LIFETIME_OR_LABEL                        (ContinueExpr(
                                                                    SOME(TKLIFETIME_OR_LABEL(LIFETIME_OR_LABEL, Pos(LIFETIME_OR_LABELleft))),
                                                                    Pos(CONTINUEleft)
                                                                ))

break_exp: BREAK %prec LOWER_THAN_EXPR                          (BreakExpr(NONE, NONE, Pos(BREAKleft)))
        | BREAK LIFETIME_OR_LABEL %prec LOWER_THAN_EXPR         (BreakExpr(SOME(TKLIFETIME_OR_LABEL(LIFETIME_OR_LABEL, Pos(LIFETIME_OR_LABELleft))), NONE, Pos(BREAKleft)))
        | BREAK expression %prec LOWER_THAN_EXPR                (BreakExpr(NONE, SOME(expression), Pos(BREAKleft)))
        | BREAK LIFETIME_OR_LABEL expression 
            %prec LOWER_THAN_EXPR                               (BreakExpr(SOME(TKLIFETIME_OR_LABEL(LIFETIME_OR_LABEL, Pos(LIFETIME_OR_LABELleft))), SOME(expression), Pos(BREAKleft)))

range_exp: expression DOTDOT expression                         (RangeExpr(expression1, expression2, Pos(DOTDOTleft)))
        | expression DOTDOT                                     (RangeFormExpr(expression, Pos(DOTDOTleft)))
        | DOTDOT expression                                     (RangeToExpr(expression, Pos(DOTDOTleft)))
        | DOTDOT                                                (RangeFullExpr(Pos(DOTDOTleft)))
        | expression DOTDOTEQ expression                        (RangeInclusiveExpr(expression1, expression2, Pos(DOTDOTEQleft)))
        | DOTDOTEQ expression                                   (RangeToInclusiveExpr(expression, Pos(DOTDOTEQleft)))

return_exp: RETURN                                              (RetrunExpr(NONE, Pos(RETURNleft)))
            | RETURN expression                                 (RetrunExpr(SOME(expression), Pos(RETURNleft)))

exp_with_block: 
            block_exp                                           (block_exp)
            (* | UNSAFE block_exp                                  () *)
            | loop_exp                                          (loop_exp)
            | if_exp                                            (if_exp)
            | if_let_exp                                        (if_let_exp)
            | match_exp                                         (match_exp)

loop_exp: maybe_loop_label LOOP block_exp                       (InfiniteLoopExpr(maybe_loop_label, block_exp, Pos(LOOPleft)))
        | maybe_loop_label WHILE exp_nostruct block_exp         (PredicateLoopExpr(maybe_loop_label, exp_nostruct, block_exp, Pos(WHILEleft)))
        | maybe_loop_label 
            WHILE LET patterns EQ exp_nostruct block_exp        (PredicatePatLoopExpr(maybe_loop_label, patterns, exp_nostruct, block_exp, Pos(WHILEleft)))
        | maybe_loop_label 
            FOR patterns IN exp_nostruct block_exp              (IteratorLoopExpr(maybe_loop_label, patterns, exp_nostruct, block_exp, Pos(FORleft)))
maybe_loop_label: LIFETIME_OR_LABEL COLON                       (SOME(LoopLabel(TKLIFETIME_OR_LABEL(LIFETIME_OR_LABEL, Pos(LIFETIME_OR_LABELleft)))))
                |                                               (NONE)

if_exp: IF exp_nostruct block_exp                               (IfExpr(exp_nostruct, block_exp, NONE, Pos(IFleft)))
        | IF exp_nostruct block_exp ELSE block_exp              (IfExpr(exp_nostruct, block_exp, SOME(block_exp), Pos(IFleft)))
        | IF exp_nostruct block_exp ELSE if_exp                 (IfExpr(exp_nostruct, block_exp, SOME(if_exp), Pos(IFleft)))
        | IF exp_nostruct block_exp ELSE if_let_exp             (IfExpr(exp_nostruct, block_exp, SOME(if_let_exp), Pos(IFleft)))

if_let_exp: IF LET patterns EQ exp_nostruct_nolazybop block_exp (IfLetExpr(patterns, exp_nostruct_nolazybop, block_exp, NONE, Pos(IFleft)))
        | IF LET patterns EQ exp_nostruct_nolazybop block_exp
            ELSE block_exp                                      (IfLetExpr(patterns, exp_nostruct_nolazybop, block_exp1, SOME(block_exp2), Pos(IFleft)))
        | IF LET patterns EQ exp_nostruct_nolazybop block_exp
            ELSE if_exp                                         (IfLetExpr(patterns, exp_nostruct_nolazybop, block_exp, SOME(if_exp), Pos(IFleft)))
        | IF LET patterns EQ exp_nostruct_nolazybop block_exp
            ELSE if_let_exp                                     (IfLetExpr(patterns, exp_nostruct_nolazybop, block_exp, SOME(if_let_exp), Pos(IFleft)))

(* match_exp: MATCH exp_nostruct LBRACE inner_attrs RBRACE         ()
        | MATCH exp_nostruct 
            LBRACE inner_attrs match_arms RBRACE                () *)
match_exp: MATCH exp_nostruct LBRACE inner_attrs RBRACE         (MatchExpr(exp_nostruct, inner_attrs, [], Pos(MATCHleft)))
        | MATCH exp_nostruct 
            LBRACE inner_attrs match_arms_clauses RBRACE        (MatchExpr(exp_nostruct, inner_attrs, rev(match_arms_clauses), Pos(MATCHleft)))
        | MATCH exp_nostruct 
            LBRACE inner_attrs match_arms_clauses 
            noblock_match_clause RBRACE                         (MatchExpr(exp_nostruct, inner_attrs, rev(noblock_match_clause::rev(match_arms_clauses)), Pos(MATCHleft)))
        | MATCH exp_nostruct 
            LBRACE inner_attrs noblock_match_clause RBRACE      (MatchExpr(exp_nostruct, inner_attrs, [noblock_match_clause], Pos(MATCHleft)))
(* match_arms: match_arms_expansion                                ()
            | match_arms_expansion exp_without_block            () *)
(* expression conatins block_exp *)
(* match_arms_expansion: 
                    (* match_arms_expansion 
                        match_arm FATARROW block_exp            () *)
                    match_arms_expansion 
                        COMMA match_arm FATARROW expression     ()
                    (* | match_arm FATARROW block_exp              () *)
                    | match_arm FATARROW expression             () *)
                 
match_arms_clauses: match_arms_clauses match_arms_clause        (match_arms_clause::match_arms_clauses)
                    | match_arms_clause                         ([match_arms_clause])
match_arms_clause: noblock_match_clause COMMA                   (noblock_match_clause)
                | block_match_clause                            (block_match_clause)
                | block_match_clause COMMA                      (block_match_clause)
noblock_match_clause: outer_attrs match_arm_patterns 
                        FATARROW noblock_exp                    (MatchArm(outer_attrs, rev(match_arm_patterns), NONE, noblock_exp))
                    | outer_attrs match_arm_patterns 
                        FATARROW exp_with_block_dot             (MatchArm(outer_attrs, rev(match_arm_patterns), NONE, exp_with_block_dot))
                    | outer_attrs match_arm_patterns 
                        match_arm_guard FATARROW noblock_exp    (MatchArm(outer_attrs, rev(match_arm_patterns), SOME(match_arm_guard), noblock_exp))
                    | outer_attrs match_arm_patterns 
                        match_arm_guard FATARROW 
                        exp_with_block_dot                      (MatchArm(outer_attrs, rev(match_arm_patterns), SOME(match_arm_guard), exp_with_block_dot))
block_match_clause: outer_attrs match_arm_patterns 
                        FATARROW exp_with_block                 (MatchArm(outer_attrs, rev(match_arm_patterns), NONE, exp_with_block))
                    | outer_attrs match_arm_patterns 
                        match_arm_guard FATARROW 
                        exp_with_block                          (MatchArm(outer_attrs, rev(match_arm_patterns), SOME(match_arm_guard), exp_with_block))

(* match_arm: outer_attrs match_arm_patterns                       ()
        | outer_attrs match_arm_patterns match_arm_guard        () *)
match_arm_patterns: match_arm_patterns OR patterns              (patterns::match_arm_patterns)
                    | OR patterns                               ([patterns])
                    | patterns                                  ([patterns])
match_arm_guard: IF expression                                  (MatchArmGuard(expression, Pos(IFleft)))

noblock_exp: lit_exp                                            (lit_exp)
            (* | path_exp %prec IDENT                                         (yaccLog("noblock_exp:path_exp")) *)
            | path_in_exp %prec IDENT                           (PathExpr(path_in_exp))
            | qualified_path_in_exp %prec IDENT                 (QPathExpr(qualified_path_in_exp))
            (* borrow noblock_exp*)
            | AND expression                                    (BorrowExpr(BOnce(Pos(ANDleft)), NonMut, expression, Pos(ANDleft)))
            | ANDAND expression                                 (BorrowExpr(BTwice(Pos(ANDANDleft)), NonMut, expression, Pos(ANDANDleft)))
            | AND MUT expression                                (BorrowExpr(BOnce(Pos(ANDleft)), Mut, expression, Pos(ANDleft)))
            | ANDAND MUT expression                             (BorrowExpr(BTwice(Pos(ANDANDleft)), Mut, expression, Pos(ANDANDleft)))
            (* dereference expression*)
            | STAR expression                                   (DereferenceExpr(expression, Pos(STARleft)))
            (* question mark operator *)
            | noblock_exp QUESTION                              (ErrorPropagationExpr(noblock_exp, Pos(QUESTIONleft)))
            (* negation expression *)
            | MINUS expression                                  (NegExpr(expression, Pos(MINUSleft)))
            | NOT expression                                    (NotExpr(expression, Pos(NOTleft)))
            (* arithmetic or logical expression *)
            | noblock_exp PLUS expression                       (ArithmeticOrLogicalExpr(noblock_exp, AddOp, expression, Pos(PLUSleft)))
            | noblock_exp MINUS expression                      (ArithmeticOrLogicalExpr(noblock_exp, SubOp, expression, Pos(MINUSleft)))
            | noblock_exp STAR expression                       (ArithmeticOrLogicalExpr(noblock_exp, MultOp, expression, Pos(STARleft)))
            | noblock_exp SLASH expression                      (ArithmeticOrLogicalExpr(noblock_exp, DiviOp, expression, Pos(SLASHleft)))
            | noblock_exp PERCENT expression                    (ArithmeticOrLogicalExpr(noblock_exp, RemainderOp, expression, Pos(PERCENTleft)))
            | noblock_exp AND expression                        (ArithmeticOrLogicalExpr(noblock_exp, AndOp, expression, Pos(ANDleft)))
            | noblock_exp OR expression                         (ArithmeticOrLogicalExpr(noblock_exp, OrOp, expression, Pos(ORleft)))
            | noblock_exp CARET expression                      (ArithmeticOrLogicalExpr(noblock_exp, XorOp, expression, Pos(CARETleft)))
            | noblock_exp SHL expression                        (ArithmeticOrLogicalExpr(noblock_exp, LShiftOp, expression, Pos(SHLleft)))
            | noblock_exp shr expression %prec SHR              (ArithmeticOrLogicalExpr(noblock_exp, RShiftOp, expression, Pos(shr)))
            (* comparision expression  *)
            | noblock_exp EQEQ expression                       (ComparisonExpr(noblock_exp, EqOp, expression, Pos(EQEQleft)))
            | noblock_exp NE expression                         (ComparisonExpr(noblock_exp, NeqOp, expression, Pos(NEleft)))
            | noblock_exp GT expression                         (ComparisonExpr(noblock_exp, GtOp, expression, Pos(GTleft)))
            | noblock_exp LT expression                         (ComparisonExpr(noblock_exp, LtOp, expression, Pos(LTleft)))
            | noblock_exp ge expression %prec GE                (ComparisonExpr(noblock_exp, GeOp, expression, Pos(ge)))
            | noblock_exp LE expression                         (ComparisonExpr(noblock_exp, LeOp, expression, Pos(LEleft)))
            (* lazy boolean expression *)
            | noblock_exp OROR expression                       (LazyBooleanExpr(noblock_exp, LazyOrOp,expression, Pos(ORORleft)))
            | noblock_exp ANDAND expression                     (LazyBooleanExpr(noblock_exp, LazyAndOp,expression, Pos(ANDANDleft)))
            (* type case noblock_exp *)
            | noblock_exp AS type_no_bounds                     (TypeCastExpr(noblock_exp, type_no_bounds, Pos(ASleft)))
            (* assignment noblock_exp *)
            | noblock_exp EQ expression                         (AssignmentExpr(noblock_exp, expression, Pos(EQleft)))
            (* compound assignment expression *)
            | noblock_exp PLUSEQ expression                     (CompoundAssignmentExpr(noblock_exp, AddEqOp,expression, Pos(PLUSEQleft)))
            | noblock_exp MINUSEQ expression                    (CompoundAssignmentExpr(noblock_exp, SubEqOp,expression, Pos(MINUSEQleft)))
            | noblock_exp STAREQ expression                     (CompoundAssignmentExpr(noblock_exp, MultEqOp,expression, Pos(STAREQleft)))
            | noblock_exp SLASHEQ expression                    (CompoundAssignmentExpr(noblock_exp, DiviEqOp,expression, Pos(SLASHEQleft)))
            | noblock_exp PERCENTEQ expression                  (CompoundAssignmentExpr(noblock_exp, RemainderEqOp,expression, Pos(PERCENTEQleft)))
            | noblock_exp ANDEQ expression                      (CompoundAssignmentExpr(noblock_exp, AndEqOp,expression, Pos(ANDEQleft)))
            | noblock_exp OREQ expression                       (CompoundAssignmentExpr(noblock_exp, OrEqOp,expression, Pos(OREQleft)))
            | noblock_exp CARETEQ expression                    (CompoundAssignmentExpr(noblock_exp, XorEqOp,expression, Pos(CARETEQleft)))
            | noblock_exp SHLEQ expression                      (CompoundAssignmentExpr(noblock_exp, LShiftEqOp,expression, Pos(SHLEQleft)))
            | noblock_exp shreq expression %prec SHREQ          (CompoundAssignmentExpr(noblock_exp, RShiftEqOp,expression, Pos(shreq)))
            | grouped_exp                                       (grouped_exp)
            | array_exp                                         (array_exp)
            | noblock_exp LBRACKET expression RBRACKET          (IndexExpr(noblock_exp, expression, Pos(LBRACKETleft)))
            | tuple_exp                                         (tuple_exp)
            (* Method Call *)
            | noblock_exp DOT IDENT LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [IDPS(Identifer(IDENT))], maybe_call_params))
            | noblock_exp DOT SUPER LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [SuperPS], maybe_call_params))
            | noblock_exp DOT SELFVALUE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [SelfValuePS], maybe_call_params))
            | noblock_exp DOT SELFTYPE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [SelfTypePS], maybe_call_params))
            | noblock_exp DOT CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [CratePS], maybe_call_params))
            | noblock_exp DOT DOLLAR CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(noblock_exp, [DCratePS], maybe_call_params))
            | noblock_exp DOT IDENT PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [IDPS(Identifer(IDENT)), GenericPS(generic_args)], maybe_call_params))
            | noblock_exp DOT SUPER PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [SuperPS, GenericPS(generic_args)], maybe_call_params))
            | noblock_exp DOT SELFVALUE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [SelfValuePS, GenericPS(generic_args)], maybe_call_params))
            | noblock_exp DOT SELFTYPE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [SelfTypePS, GenericPS(generic_args)], maybe_call_params))
            | noblock_exp DOT CRATE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [CratePS, GenericPS(generic_args)], maybe_call_params))
            | noblock_exp DOT DOLLAR CRATE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(noblock_exp, [DCratePS, GenericPS(generic_args)], maybe_call_params))
            (* tuple index *)
            | noblock_exp DOT INTEGER_LIT                       (TupleIndexingExpr(noblock_exp, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))
            (* call *)
            | noblock_exp LPARENT RPARENT                       (CallExpr(noblock_exp, [], Pos(LPARENTleft)))
            | noblock_exp LPARENT call_params RPARENT           (CallExpr(noblock_exp, call_params, Pos(LPARENTleft)))
            (* field *)
            | noblock_exp DOT IDENT                             (FieldExpr(noblock_exp, [IDPS(Identifer(IDENT))], Pos(DOTleft)))
            (* clousre *)
            | OROR expression                                   (ClosureExpr(NONE, [], NONE, expression, Pos(ORORleft)))
            | OROR RARROW type_no_bounds block_exp              (ClosureExpr(NONE, [], SOME(type_no_bounds), block_exp, Pos(ORORleft)))
            | MOVE OROR expression                              (ClosureExpr(SOME(Move), [], NONE, expression, Pos(MOVEleft)))
            | MOVE OROR RARROW type_no_bounds block_exp         (ClosureExpr(SOME(Move), [], SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | OR closure_parameters OR expression               (ClosureExpr(NONE, closure_parameters, NONE, expression, Pos(ORleft)))
            | OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(NONE, closure_parameters, SOME(type_no_bounds), block_exp, Pos(ORleft)))
            | MOVE OR closure_parameters OR expression          (ClosureExpr(SOME(Move), closure_parameters, NONE, expression, Pos(MOVEleft)))
            | MOVE OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(SOME(Move), closure_parameters, SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | struct_exp                                        (struct_exp)
            | continue_exp                                      (continue_exp)
            | break_exp                                         (break_exp)
            (* range *)
            | noblock_exp DOTDOT expression                     (RangeExpr(noblock_exp, expression, Pos(DOTDOTleft)))
            | noblock_exp DOTDOT                                (RangeFormExpr(noblock_exp, Pos(DOTDOTleft)))
            | DOTDOT expression                                 (RangeToExpr(expression, Pos(DOTDOTleft)))
            | DOTDOT                                            (RangeFullExpr(Pos(DOTDOTleft)))
            | noblock_exp DOTDOTEQ expression                   (RangeInclusiveExpr(noblock_exp, expression, Pos(DOTDOTEQleft)))
            | DOTDOTEQ expression                               (RangeToInclusiveExpr(expression, Pos(DOTDOTEQleft)))
            | return_exp                                        (return_exp)
            | macro_invocation                                  (MacroExpr(macro_invocation))
full_block_exp: exp_with_block                                  (exp_with_block)
                | exp_with_block_dot                            (exp_with_block_dot)
exp_with_block_dot: exp_with_block 
                    DOT path_in_exp_with_generic                (FieldExpr(exp_with_block, path_in_exp_with_generic, Pos(DOTleft)))
                | exp_with_block_dot 
                    DOT path_in_exp_with_generic                (FieldExpr(exp_with_block_dot, path_in_exp_with_generic, Pos(DOTleft)))
                | exp_with_block 
                    DOT path_in_exp_with_generic 
                    LBRACKET expression RBRACKET                (IndexExpr(FieldExpr(exp_with_block, path_in_exp_with_generic, Pos(DOTleft)), expression, Pos(LBRACKETleft)))
                | exp_with_block_dot 
                    DOT path_in_exp_with_generic
                    LBRACKET expression RBRACKET                (IndexExpr(FieldExpr(exp_with_block_dot, path_in_exp_with_generic, Pos(DOTleft)), expression, Pos(LBRACKETleft)))
                | exp_with_block 
                    DOT path_in_exp_with_generic 
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(exp_with_block, path_in_exp_with_generic, maybe_call_params))
                | exp_with_block_dot 
                    DOT path_in_exp_with_generic
                    LPARENT maybe_call_params RPARENT           (MethodCallExpr(exp_with_block_dot, path_in_exp_with_generic, maybe_call_params))
                | exp_with_block 
                    DOT INTEGER_LIT                             (TupleIndexingExpr(exp_with_block, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))
                | exp_with_block_dot 
                    DOT INTEGER_LIT                             (TupleIndexingExpr(exp_with_block_dot, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))

exp_nostruct: lit_exp                                           (lit_exp)
            (* | path_exp %prec IDENT                                         (yaccLog("exp_nostruct:path_exp")) *)
            | path_in_exp %prec IDENT                           (PathExpr(path_in_exp))
            | qualified_path_in_exp %prec IDENT                 (QPathExpr(qualified_path_in_exp))
            (* borrow exp_nostruct*)
            | AND exp_nostruct                                  (BorrowExpr(BOnce(Pos(ANDleft)), NonMut, exp_nostruct, Pos(ANDleft)))
            | ANDAND exp_nostruct                               (BorrowExpr(BTwice(Pos(ANDANDleft)), NonMut, exp_nostruct, Pos(ANDANDleft)))
            | AND MUT exp_nostruct                              (BorrowExpr(BOnce(Pos(ANDleft)), Mut, exp_nostruct, Pos(ANDleft)))
            | ANDAND MUT exp_nostruct                           (BorrowExpr(BTwice(Pos(ANDANDleft)), Mut, exp_nostruct, Pos(ANDANDleft)))
            (* dereference exp_nostruct*)
            | STAR exp_nostruct                                 (DereferenceExpr(exp_nostruct, Pos(STARleft)))
            (* question mark operator *)
            | exp_nostruct QUESTION                             (ErrorPropagationExpr(exp_nostruct, Pos(QUESTIONleft)))
            (* negation exp_nostruct *)
            | MINUS exp_nostruct                                (NegExpr(exp_nostruct, Pos(MINUSleft)))
            | NOT exp_nostruct                                  (NotExpr(exp_nostruct, Pos(NOTleft)))
            (* arithmetic or logical expression *)
            | exp_nostruct PLUS exp_nostruct                    (ArithmeticOrLogicalExpr(exp_nostruct1, AddOp, exp_nostruct2, Pos(PLUSleft)))
            | exp_nostruct MINUS exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, SubOp, exp_nostruct2, Pos(MINUSleft)))
            | exp_nostruct STAR exp_nostruct                    (ArithmeticOrLogicalExpr(exp_nostruct1, MultOp, exp_nostruct2, Pos(STARleft)))
            | exp_nostruct SLASH exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, DiviOp, exp_nostruct2, Pos(SLASHleft)))
            | exp_nostruct PERCENT exp_nostruct                 (ArithmeticOrLogicalExpr(exp_nostruct1, RemainderOp, exp_nostruct2, Pos(PERCENTleft)))
            | exp_nostruct AND exp_nostruct                     (ArithmeticOrLogicalExpr(exp_nostruct1, AndOp, exp_nostruct2, Pos(ANDleft)))
            | exp_nostruct OR exp_nostruct                      (ArithmeticOrLogicalExpr(exp_nostruct1, OrOp, exp_nostruct2, Pos(ORleft)))
            | exp_nostruct CARET exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, XorOp, exp_nostruct2, Pos(CARETleft)))
            | exp_nostruct SHL exp_nostruct                     (ArithmeticOrLogicalExpr(exp_nostruct1, LShiftOp, exp_nostruct2, Pos(SHLleft)))
            | exp_nostruct shr exp_nostruct %prec SHR           (ArithmeticOrLogicalExpr(exp_nostruct1, RShiftOp, exp_nostruct2, Pos(shr)))
            (* comparision expression  *)
            | exp_nostruct EQEQ exp_nostruct                    (ComparisonExpr(exp_nostruct1, EqOp, exp_nostruct2, Pos(EQEQleft)))
            | exp_nostruct NE exp_nostruct                      (ComparisonExpr(exp_nostruct1, NeqOp, exp_nostruct2, Pos(NEleft)))
            | exp_nostruct GT exp_nostruct                      (ComparisonExpr(exp_nostruct1, GtOp, exp_nostruct2, Pos(GTleft)))
            | exp_nostruct LT exp_nostruct                      (ComparisonExpr(exp_nostruct1, LtOp, exp_nostruct2, Pos(LTleft)))
            | exp_nostruct ge exp_nostruct %prec GE             (ComparisonExpr(exp_nostruct1, GeOp, exp_nostruct2, Pos(ge)))
            | exp_nostruct LE exp_nostruct                      (ComparisonExpr(exp_nostruct1, LeOp, exp_nostruct2, Pos(LEleft)))
            (* lazy boolean expression *)
            | exp_nostruct OROR exp_nostruct                    (LazyBooleanExpr(exp_nostruct1, LazyOrOp,exp_nostruct2, Pos(ORORleft)))
            | exp_nostruct ANDAND exp_nostruct                  (LazyBooleanExpr(exp_nostruct1, LazyAndOp,exp_nostruct2, Pos(ANDANDleft)))
            (* type case exp_nostruct *)
            | exp_nostruct AS type_no_bounds                    (TypeCastExpr(exp_nostruct, type_no_bounds, Pos(ASleft)))
            (* assignment exp_nostruct *)
            | exp_nostruct EQ exp_nostruct                      (AssignmentExpr(exp_nostruct1, exp_nostruct2, Pos(EQleft)))
            (* compound assignment expression *)
            | exp_nostruct PLUSEQ exp_nostruct                  (CompoundAssignmentExpr(exp_nostruct1, AddEqOp,exp_nostruct2, Pos(PLUSEQleft)))
            | exp_nostruct MINUSEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, SubEqOp,exp_nostruct2, Pos(MINUSEQleft)))
            | exp_nostruct STAREQ exp_nostruct                  (CompoundAssignmentExpr(exp_nostruct1, MultEqOp,exp_nostruct2, Pos(STAREQleft)))
            | exp_nostruct SLASHEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, DiviEqOp,exp_nostruct2, Pos(SLASHEQleft)))
            | exp_nostruct PERCENTEQ exp_nostruct               (CompoundAssignmentExpr(exp_nostruct1, RemainderEqOp,exp_nostruct2, Pos(PERCENTEQleft)))
            | exp_nostruct ANDEQ exp_nostruct                   (CompoundAssignmentExpr(exp_nostruct1, AndEqOp,exp_nostruct2, Pos(ANDEQleft)))
            | exp_nostruct OREQ exp_nostruct                    (CompoundAssignmentExpr(exp_nostruct1, OrEqOp,exp_nostruct2, Pos(OREQleft)))
            | exp_nostruct CARETEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, XorEqOp,exp_nostruct2, Pos(CARETEQleft)))
            | exp_nostruct SHLEQ exp_nostruct                   (CompoundAssignmentExpr(exp_nostruct1, LShiftEqOp,exp_nostruct2, Pos(SHLEQleft)))
            | exp_nostruct shreq exp_nostruct %prec SHREQ       (CompoundAssignmentExpr(exp_nostruct1, RShiftEqOp,exp_nostruct2, Pos(shreq)))
            | grouped_exp                                       (grouped_exp)
            | array_exp                                         (array_exp)
            | exp_nostruct LBRACKET expression RBRACKET         (IndexExpr(exp_nostruct, expression, Pos(LBRACKETleft)))
            | tuple_exp                                         (tuple_exp)
            (* Method Call *)
            | exp_nostruct DOT IDENT LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [IDPS(Identifer(IDENT))], maybe_call_params))
            | exp_nostruct DOT SUPER LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SuperPS], maybe_call_params))
            | exp_nostruct DOT SELFVALUE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SelfValuePS], maybe_call_params))
            | exp_nostruct DOT SELFTYPE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SelfTypePS], maybe_call_params))
            | exp_nostruct DOT CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [CratePS], maybe_call_params))
            | exp_nostruct DOT DOLLAR CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [DCratePS], maybe_call_params))
            | exp_nostruct DOT IDENT PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [IDPS(Identifer(IDENT)), GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SUPER PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SuperPS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SELFVALUE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SelfValuePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SELFTYPE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SelfTypePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT CRATE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [CratePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT DOLLAR CRATE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [DCratePS, GenericPS(generic_args)], maybe_call_params))
            (* tuple index *)
            | exp_nostruct DOT INTEGER_LIT                      (TupleIndexingExpr(exp_nostruct, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))
            (* call *)
            | exp_nostruct LPARENT RPARENT                      (CallExpr(exp_nostruct, [], Pos(LPARENTleft)))
            | exp_nostruct LPARENT call_params RPARENT          (CallExpr(exp_nostruct, call_params, Pos(LPARENTleft)))
            (* field *)
            | exp_nostruct DOT IDENT                            (FieldExpr(exp_nostruct, [IDPS(Identifer(IDENT))], Pos(DOTleft)))
            (* clousre *)
            | OROR exp_nostruct                                 (ClosureExpr(NONE, [], NONE, exp_nostruct, Pos(ORORleft)))
            | OROR RARROW type_no_bounds block_exp              (ClosureExpr(NONE, [], SOME(type_no_bounds), block_exp, Pos(ORORleft)))
            | MOVE OROR exp_nostruct                            (ClosureExpr(SOME(Move), [], NONE, exp_nostruct, Pos(MOVEleft)))
            | MOVE OROR RARROW type_no_bounds block_exp         (ClosureExpr(SOME(Move), [], SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | OR closure_parameters OR exp_nostruct             (ClosureExpr(NONE, closure_parameters, NONE, exp_nostruct, Pos(ORleft)))
            | OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(NONE, closure_parameters, SOME(type_no_bounds), block_exp, Pos(ORleft)))
            | MOVE OR closure_parameters OR exp_nostruct        (ClosureExpr(SOME(Move), closure_parameters, NONE, exp_nostruct, Pos(MOVEleft)))
            | MOVE OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(SOME(Move), closure_parameters, SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | continue_exp                                      (continue_exp)
            | break_exp                                         (break_exp)
            (* range *)
            | exp_nostruct DOTDOT exp_nostruct                  (RangeExpr(exp_nostruct1, exp_nostruct2, Pos(DOTDOTleft)))
            | exp_nostruct DOTDOT                               (RangeFormExpr(exp_nostruct, Pos(DOTDOTleft)))
            | DOTDOT exp_nostruct                               (RangeToExpr(exp_nostruct, Pos(DOTDOTleft)))
            | DOTDOT                                            (RangeFullExpr(Pos(DOTDOTleft)))
            | exp_nostruct DOTDOTEQ exp_nostruct                (RangeInclusiveExpr(exp_nostruct1, exp_nostruct2, Pos(DOTDOTEQleft)))
            | DOTDOTEQ exp_nostruct                             (RangeToInclusiveExpr(exp_nostruct, Pos(DOTDOTEQleft)))
            | return_exp                                        (return_exp)
            | exp_with_block                                    (exp_with_block)
            | macro_invocation                                  (MacroExpr(macro_invocation))

exp_nostruct_nolazybop: 
             lit_exp                                            (lit_exp)
            (* | path_exp %prec IDENT                                         (yaccLog("exp_nostruct:path_exp")) *)
            | path_in_exp %prec IDENT                           (PathExpr(path_in_exp))
            | qualified_path_in_exp %prec IDENT                 (QPathExpr(qualified_path_in_exp))
            (* borrow exp_nostruct*)
            | AND exp_nostruct                                  (BorrowExpr(BOnce(Pos(ANDleft)), NonMut, exp_nostruct, Pos(ANDleft)))
            | ANDAND exp_nostruct                               (BorrowExpr(BTwice(Pos(ANDANDleft)), NonMut, exp_nostruct, Pos(ANDANDleft)))
            | AND MUT exp_nostruct                              (BorrowExpr(BOnce(Pos(ANDleft)), Mut, exp_nostruct, Pos(ANDleft)))
            | ANDAND MUT exp_nostruct                           (BorrowExpr(BTwice(Pos(ANDANDleft)), Mut, exp_nostruct, Pos(ANDANDleft)))
            (* dereference exp_nostruct*)
            | STAR exp_nostruct                                 (DereferenceExpr(exp_nostruct, Pos(STARleft)))
            (* question mark operator *)
            | exp_nostruct QUESTION                             (ErrorPropagationExpr(exp_nostruct, Pos(QUESTIONleft)))
            (* negation exp_nostruct *)
            | MINUS exp_nostruct                                (NegExpr(exp_nostruct, Pos(MINUSleft)))
            | NOT exp_nostruct                                  (NotExpr(exp_nostruct, Pos(NOTleft)))
            (* arithmetic or logical expression *)
            | exp_nostruct PLUS exp_nostruct                    (ArithmeticOrLogicalExpr(exp_nostruct1, AddOp, exp_nostruct2, Pos(PLUSleft)))
            | exp_nostruct MINUS exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, SubOp, exp_nostruct2, Pos(MINUSleft)))
            | exp_nostruct STAR exp_nostruct                    (ArithmeticOrLogicalExpr(exp_nostruct1, MultOp, exp_nostruct2, Pos(STARleft)))
            | exp_nostruct SLASH exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, DiviOp, exp_nostruct2, Pos(SLASHleft)))
            | exp_nostruct PERCENT exp_nostruct                 (ArithmeticOrLogicalExpr(exp_nostruct1, RemainderOp, exp_nostruct2, Pos(PERCENTleft)))
            | exp_nostruct AND exp_nostruct                     (ArithmeticOrLogicalExpr(exp_nostruct1, AndOp, exp_nostruct2, Pos(ANDleft)))
            | exp_nostruct OR exp_nostruct                      (ArithmeticOrLogicalExpr(exp_nostruct1, OrOp, exp_nostruct2, Pos(ORleft)))
            | exp_nostruct CARET exp_nostruct                   (ArithmeticOrLogicalExpr(exp_nostruct1, XorOp, exp_nostruct2, Pos(CARETleft)))
            | exp_nostruct SHL exp_nostruct                     (ArithmeticOrLogicalExpr(exp_nostruct1, LShiftOp, exp_nostruct2, Pos(SHLleft)))
            | exp_nostruct shr exp_nostruct %prec SHR           (ArithmeticOrLogicalExpr(exp_nostruct1, RShiftOp, exp_nostruct2, Pos(shr)))
            (* comparision expression  *)
            | exp_nostruct EQEQ exp_nostruct                    (ComparisonExpr(exp_nostruct1, EqOp, exp_nostruct2, Pos(EQEQleft)))
            | exp_nostruct NE exp_nostruct                      (ComparisonExpr(exp_nostruct1, NeqOp, exp_nostruct2, Pos(NEleft)))
            | exp_nostruct GT exp_nostruct                      (ComparisonExpr(exp_nostruct1, GtOp, exp_nostruct2, Pos(GTleft)))
            | exp_nostruct LT exp_nostruct                      (ComparisonExpr(exp_nostruct1, LtOp, exp_nostruct2, Pos(LTleft)))
            | exp_nostruct ge exp_nostruct %prec GE             (ComparisonExpr(exp_nostruct1, GeOp, exp_nostruct2, Pos(ge)))
            | exp_nostruct LE exp_nostruct                      (ComparisonExpr(exp_nostruct1, LeOp, exp_nostruct2, Pos(LEleft)))
            (* lazy boolean expression *)
            (* | exp_nostruct OROR exp_nostruct                    (LazyBooleanExpr(exp_nostruct1, LazyOrOp,exp_nostruct2, Pos(ORORleft)))
            | exp_nostruct ANDAND exp_nostruct                  (LazyBooleanExpr(exp_nostruct1, LazyAndOp,exp_nostruct2, Pos(ANDANDleft))) *)
            (* type case exp_nostruct *)
            | exp_nostruct AS type_no_bounds                    (TypeCastExpr(exp_nostruct, type_no_bounds, Pos(ASleft)))
            (* assignment exp_nostruct *)
            | exp_nostruct EQ exp_nostruct                      (AssignmentExpr(exp_nostruct1, exp_nostruct2, Pos(EQleft)))
            (* compound assignment expression *)
            | exp_nostruct PLUSEQ exp_nostruct                  (CompoundAssignmentExpr(exp_nostruct1, AddEqOp,exp_nostruct2, Pos(PLUSEQleft)))
            | exp_nostruct MINUSEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, SubEqOp,exp_nostruct2, Pos(MINUSEQleft)))
            | exp_nostruct STAREQ exp_nostruct                  (CompoundAssignmentExpr(exp_nostruct1, MultEqOp,exp_nostruct2, Pos(STAREQleft)))
            | exp_nostruct SLASHEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, DiviEqOp,exp_nostruct2, Pos(SLASHEQleft)))
            | exp_nostruct PERCENTEQ exp_nostruct               (CompoundAssignmentExpr(exp_nostruct1, RemainderEqOp,exp_nostruct2, Pos(PERCENTEQleft)))
            | exp_nostruct ANDEQ exp_nostruct                   (CompoundAssignmentExpr(exp_nostruct1, AndEqOp,exp_nostruct2, Pos(ANDEQleft)))
            | exp_nostruct OREQ exp_nostruct                    (CompoundAssignmentExpr(exp_nostruct1, OrEqOp,exp_nostruct2, Pos(OREQleft)))
            | exp_nostruct CARETEQ exp_nostruct                 (CompoundAssignmentExpr(exp_nostruct1, XorEqOp,exp_nostruct2, Pos(CARETEQleft)))
            | exp_nostruct SHLEQ exp_nostruct                   (CompoundAssignmentExpr(exp_nostruct1, LShiftEqOp,exp_nostruct2, Pos(SHLEQleft)))
            | exp_nostruct shreq exp_nostruct %prec SHREQ       (CompoundAssignmentExpr(exp_nostruct1, RShiftEqOp,exp_nostruct2, Pos(shreq)))
            | grouped_exp                                       (grouped_exp)
            | array_exp                                         (array_exp)
            | exp_nostruct LBRACKET expression RBRACKET         (IndexExpr(exp_nostruct, expression, Pos(LBRACKETleft)))
            | tuple_exp                                         (tuple_exp)
            (* Method Call *)
            | exp_nostruct DOT IDENT LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [IDPS(Identifer(IDENT))], maybe_call_params))
            | exp_nostruct DOT SUPER LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SuperPS], maybe_call_params))
            | exp_nostruct DOT SELFVALUE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SelfValuePS], maybe_call_params))
            | exp_nostruct DOT SELFTYPE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [SelfTypePS], maybe_call_params))
            | exp_nostruct DOT CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [CratePS], maybe_call_params))
            | exp_nostruct DOT DOLLAR CRATE LPARENT
                maybe_call_params RPARENT                       (MethodCallExpr(exp_nostruct, [DCratePS], maybe_call_params))
            | exp_nostruct DOT IDENT PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [IDPS(Identifer(IDENT)), GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SUPER PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SuperPS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SELFVALUE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SelfValuePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT SELFTYPE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [SelfTypePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT CRATE PATHSEP generic_args
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [CratePS, GenericPS(generic_args)], maybe_call_params))
            | exp_nostruct DOT DOLLAR CRATE PATHSEP generic_args 
                LPARENT maybe_call_params RPARENT               (MethodCallExpr(exp_nostruct, [DCratePS, GenericPS(generic_args)], maybe_call_params))
            (* tuple index *)
            | exp_nostruct DOT INTEGER_LIT                      (TupleIndexingExpr(exp_nostruct, TKTUPLE_INDEX(INTEGER_LIT, Pos(INTEGER_LITleft)), Pos(DOTleft)))
            (* call *)
            | exp_nostruct LPARENT RPARENT                      (CallExpr(exp_nostruct, [], Pos(LPARENTleft)))
            | exp_nostruct LPARENT call_params RPARENT          (CallExpr(exp_nostruct, call_params, Pos(LPARENTleft)))
            (* field *)
            | exp_nostruct DOT IDENT                            (FieldExpr(exp_nostruct, [IDPS(Identifer(IDENT))], Pos(DOTleft)))
            (* clousre *)
            | OROR exp_nostruct                                 (ClosureExpr(NONE, [], NONE, exp_nostruct, Pos(ORORleft)))
            | OROR RARROW type_no_bounds block_exp              (ClosureExpr(NONE, [], SOME(type_no_bounds), block_exp, Pos(ORORleft)))
            | MOVE OROR exp_nostruct                            (ClosureExpr(SOME(Move), [], NONE, exp_nostruct, Pos(MOVEleft)))
            | MOVE OROR RARROW type_no_bounds block_exp         (ClosureExpr(SOME(Move), [], SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | OR closure_parameters OR exp_nostruct             (ClosureExpr(NONE, closure_parameters, NONE, exp_nostruct, Pos(ORleft)))
            | OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(NONE, closure_parameters, SOME(type_no_bounds), block_exp, Pos(ORleft)))
            | MOVE OR closure_parameters OR exp_nostruct        (ClosureExpr(SOME(Move), closure_parameters, NONE, exp_nostruct, Pos(MOVEleft)))
            | MOVE OR closure_parameters OR 
                RARROW type_no_bounds block_exp                 (ClosureExpr(SOME(Move), closure_parameters, SOME(type_no_bounds), block_exp, Pos(MOVEleft)))
            | continue_exp                                      (continue_exp)
            | break_exp                                         (break_exp)
            (* range *)
            | exp_nostruct DOTDOT exp_nostruct                  (RangeExpr(exp_nostruct1, exp_nostruct2, Pos(DOTDOTleft)))
            | exp_nostruct DOTDOT                               (RangeFormExpr(exp_nostruct, Pos(DOTDOTleft)))
            | DOTDOT exp_nostruct                               (RangeToExpr(exp_nostruct, Pos(DOTDOTleft)))
            | DOTDOT                                            (RangeFullExpr(Pos(DOTDOTleft)))
            | exp_nostruct DOTDOTEQ exp_nostruct                (RangeInclusiveExpr(exp_nostruct1, exp_nostruct2, Pos(DOTDOTEQleft)))
            | DOTDOTEQ exp_nostruct                             (RangeToInclusiveExpr(exp_nostruct, Pos(DOTDOTEQleft)))
            | return_exp                                        (return_exp)
            | exp_with_block                                    (exp_with_block)
            | macro_invocation                                  (MacroExpr(macro_invocation))

(* -----token------- *)
token_no_delim_kleene_dollar: 
              AS                                                (TKAS(Pos(ASleft)))
            | BREAK                                             (TKBREAK(Pos(BREAKleft)))
            | CONST                                             (TKCONST(Pos(CONSTleft)))
            | CONTINUE                                          (TKCONTINUE(Pos(CONTINUEleft)))
            | CRATE                                             (TKCRATE(Pos(CRATEleft)))
            | ELSE                                              (TKELSE(Pos(ELSEleft)))
            | ENUM                                              (TKENUM(Pos(ENUMleft)))
            | EXTERN                                            (TKEXTERN(Pos(EXTERNleft)))
            | FALSE                                             (TKFALSE(Pos(FALSEleft)))
            | FN                                                (TKFN(Pos(FNleft)))
            | FOR                                               (TKFOR(Pos(FORleft)))
            | IF                                                (TKIF(Pos(IFleft)))
            | IMPL                                              (TKIMPL(Pos(IMPLleft)))
            | IN                                                (TKIN(Pos(INleft)))
            | LET                                               (TKLET(Pos(LETleft)))
            | LOOP                                              (TKLOOP(Pos(LOOPleft)))
            | MATCH                                             (TKMATCH(Pos(MATCHleft)))
            | MOD                                               (TKMOD(Pos(MODleft)))
            | MOVE                                              (TKMOVE(Pos(MOVEleft)))
            | MUT                                               (TKMUT(Pos(MUTleft)))
            | PUB                                               (TKPUB(Pos(PUBleft)))
            | REF                                               (TKREF(Pos(REFleft)))
            | RETURN                                            (TKRETURN(Pos(RETURNleft)))
            | SELFVALUE                                         (TKSELFVALUE(Pos(SELFVALUEleft)))
            | SELFTYPE                                          (TKSELFTYPE(Pos(SELFTYPEleft)))
            | STATIC                                            (TKSTATIC(Pos(STATICleft)))
            | STRUCT                                            (TKSTRUCT(Pos(STRUCTleft)))
            | SUPER                                             (TKSUPER(Pos(SUPERleft)))
            | TRAIT                                             (TKTRAIT(Pos(TRAITleft)))
            | TRUE                                              (TKTRUE(Pos(TRUEleft)))
            | TYPE                                              (TKTYPE(Pos(TYPEleft)))
            | UNSAFE                                            (TKUNSAFE(Pos(UNSAFEleft)))
            | USE                                               (TKUSE(Pos(USEleft)))
            | WHERE                                             (TKWHERE(Pos(WHEREleft)))
            | WHILE                                             (TKWHILE(Pos(WHILEleft)))
            | DYN                                               (TKDYN(Pos(DYNleft)))
            | ABSTRACT                                          (TKABSTRACT(Pos(ABSTRACTleft)))
            | BECOME                                            (TKBECOME(Pos(BECOMEleft)))
            | BOX                                               (TKBOX(Pos(BOXleft)))
            | DO                                                (TKDO(Pos(DOleft)))
            | FINAL                                             (TKFINAL(Pos(FINALleft)))
            | MACRO                                             (TKMACRO(Pos(MACROleft)))
            | OVERRIDE                                          (TKOVERRIDE(Pos(OVERRIDEleft)))
            | PRIV                                              (TKPRIV(Pos(PRIVleft)))
            | TYPEOF                                            (TKTYPEOF(Pos(TYPEOFleft)))
            | UNSIZED                                           (TKUNSIZED(Pos(UNSIZEDleft)))
            | VIRTUAL                                           (TKVIRTUAL(Pos(VIRTUALleft)))
            | YIELD                                             (TKYIELD(Pos(YIELDleft)))
            | ASYNC                                             (TKASYNC(Pos(ASYNCleft)))
            | AWAIT                                             (TKAWAIT(Pos(AWAITleft)))
            | TRY                                               (TKTRY(Pos(TRYleft)))
            | UNION                                             (TKUNION(Pos(UNIONleft)))
            | STATICLIFETIME                                    (TKSTATICLIFETIME(Pos(STATICLIFETIMEleft)))
            | IDENT                                             (TKIDENT(IDENT, Pos(IDENTleft)))
            | CHAR_LIT                                          (TKCHAR_LIT(CHAR_LIT, Pos(CHAR_LITleft)))
            | STR_LIT                                           (TKSTR_LIT(STR_LIT, Pos(STR_LITleft)))
            | RAW_STR_LIT                                       (TKRAW_STR_LIT(RAW_STR_LIT, Pos(RAW_STR_LITleft)))
            | BYTE_LIT                                          (TKBYTE_LIT(BYTE_LIT, Pos(BYTE_LITleft)))
            | BYTE_STR_LIT                                      (TKBYTE_STR_LIT(BYTE_STR_LIT, Pos(BYTE_STR_LITleft)))
            | RAW_BYTE_STR_LIT                                  (TKRAW_BYTE_STR_LIT(RAW_BYTE_STR_LIT, Pos(RAW_BYTE_STR_LITleft)))
            | INTEGER_LIT                                       (TKINTEGER_LIT(INTEGER_LIT, Pos(INTEGER_LITleft)))
            | TUPLE_INDEX                                       (TKTUPLE_INDEX(TUPLE_INDEX, Pos(TUPLE_INDEXleft)))
            | FLOAT_LIT                                         (TKFLOAT_LIT(FLOAT_LIT, Pos(FLOAT_LITleft)))
            | LIFETIME_OR_LABEL                                 (TKLIFETIME_OR_LABEL(LIFETIME_OR_LABEL, Pos(LIFETIME_OR_LABELleft)))
            | LIFETIME_TOKEN                                    (TKLIFETIME_TOKEN(LIFETIME_TOKEN, Pos(LIFETIME_TOKENleft)))
            | MINUS                                             (TKMINUS(Pos(MINUSleft)))
            | SLASH                                             (TKSLASH(Pos(SLASHleft)))
            | PERCENT                                           (TKPERCENT(Pos(PERCENTleft)))
            | CARET                                             (TKCARET(Pos(CARETleft)))
            | NOT                                               (TKNOT(Pos(NOTleft)))
            | AND                                               (TKAND(Pos(ANDleft)))
            | OR                                                (TKOR(Pos(ORleft)))
            | ANDAND                                            (TKANDAND(Pos(ANDANDleft)))
            | OROR                                              (TKOROR(Pos(ORORleft)))
            | SHL                                               (TKSHL(Pos(SHLleft)))
            | shr                                               (TKSHR(Pos(shr)))
            | PLUSEQ                                            (TKPLUSEQ(Pos(PLUSEQleft)))
            | MINUSEQ                                           (TKMINUSEQ(Pos(MINUSEQleft)))
            | STAREQ                                            (TKSTAREQ(Pos(STAREQleft)))
            | SLASHEQ                                           (TKSLASHEQ(Pos(SLASHEQleft)))
            | PERCENTEQ                                         (TKPERCENTEQ(Pos(PERCENTEQleft)))
            | CARETEQ                                           (TKCARETEQ(Pos(CARETEQleft)))
            | ANDEQ                                             (TKANDEQ(Pos(ANDEQleft)))
            | OREQ                                              (TKOREQ(Pos(OREQleft)))
            | SHLEQ                                             (TKSHLEQ(Pos(SHLEQleft)))
            | shreq                                             (TKSHREQ(Pos(shreq)))
            | EQ                                                (TKEQ(Pos(EQleft)))
            | EQEQ                                              (TKEQEQ(Pos(EQEQleft)))
            | NE                                                (TKNE(Pos(NEleft)))
            | GT                                                (TKGT(Pos(GTleft)))
            | LT                                                (TKLT(Pos(LTleft)))
            | ge                                                (TKGE(Pos(ge)))
            | LE                                                (TKLE(Pos(LEleft)))
            | AT                                                (TKAT(Pos(ATleft)))
            | UNDERSCORE                                        (TKUNDERSCORE(Pos(UNDERSCOREleft)))
            | DOT                                               (TKDOT(Pos(DOTleft)))
            | DOTDOT                                            (TKDOTDOT(Pos(DOTDOTleft)))
            | DOTDOTDOT                                         (TKDOTDOTDOT(Pos(DOTDOTDOTleft)))
            | DOTDOTEQ                                          (TKDOTDOTEQ(Pos(DOTDOTEQleft)))
            | COMMA                                             (TKCOMMA(Pos(COMMAleft)))
            | SEMI                                              (TKSEMI(Pos(SEMIleft)))
            | COLON                                             (TKCOLON(Pos(COLONleft)))
            | PATHSEP                                           (TKPATHSEP(Pos(PATHSEPleft)))
            | RARROW                                            (TKRARROW(Pos(RARROWleft)))
            | FATARROW                                          (TKFATARROW(Pos(FATARROWleft)))
            | POUND                                             (TKPOUND(Pos(POUNDleft)))
            | INNER_DOC_COMMENT                                 (TKINNER_DOC_COMMENT(INNER_DOC_COMMENT, Pos(INNER_DOC_COMMENTleft)))
            | OUTER_DOC_COMMENT                                 (TKOUTER_DOC_COMMENT(OUTER_DOC_COMMENT, Pos(OUTER_DOC_COMMENTleft)))
            | SHEBANG                                           (TKSHEBANG(Pos(SHEBANGleft)))
token_no_delim_kleene: token_no_delim_kleene_dollar             (token_no_delim_kleene_dollar)
                    | DOLLAR                                    (TKDOLLAR(Pos(DOLLARleft)))
token_no_delim_dollar: token_no_delim_kleene_dollar             (token_no_delim_kleene_dollar)
                | PLUS                                          (TKPLUS(Pos(PLUSleft)))
                | STAR                                          (TKSTAR(Pos(STARleft)))
                | QUESTION                                      (TKQUESTION(Pos(QUESTIONleft)))
token_no_delim: token_no_delim_dollar                           (token_no_delim_dollar)
                | DOLLAR                                        (TKDOLLAR(Pos(DOLLARleft)))
(* syntax token *)
shr: GT GT                                                      (GT1left)
ge: GT EQ                                                       (GTleft)
shreq: GT GT EQ                                                 (GT1left)
(* shl: LT LT                                                      ((LT1left, LT2right)) *)