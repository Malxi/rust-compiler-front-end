functor RustLexFun(structure Tokens: Rust_TOKENS)  = struct

    structure yyInput : sig

        type stream
	val mkStream : (int -> string) -> stream
	val fromStream : TextIO.StreamIO.instream -> stream
	val getc : stream -> (Char.char * stream) option
	val getpos : stream -> int
	val getlineNo : stream -> int
	val subtract : stream * stream -> string
	val eof : stream -> bool
	val lastWasNL : stream -> bool

      end = struct

        structure TIO = TextIO
        structure TSIO = TIO.StreamIO
	structure TPIO = TextPrimIO

        datatype stream = Stream of {
            strm : TSIO.instream,
	    id : int,  (* track which streams originated 
			* from the same stream *)
	    pos : int,
	    lineNo : int,
	    lastWasNL : bool
          }

	local
	  val next = ref 0
	in
	fun nextId() = !next before (next := !next + 1)
	end

	val initPos = 2 (* ml-lex bug compatibility *)

	fun mkStream inputN = let
              val strm = TSIO.mkInstream 
			   (TPIO.RD {
			        name = "lexgen",
				chunkSize = 4096,
				readVec = SOME inputN,
				readArr = NONE,
				readVecNB = NONE,
				readArrNB = NONE,
				block = NONE,
				canInput = NONE,
				avail = (fn () => NONE),
				getPos = NONE,
				setPos = NONE,
				endPos = NONE,
				verifyPos = NONE,
				close = (fn () => ()),
				ioDesc = NONE
			      }, "")
	      in 
		Stream {strm = strm, id = nextId(), pos = initPos, lineNo = 1,
			lastWasNL = true}
	      end

	fun fromStream strm = Stream {
		strm = strm, id = nextId(), pos = initPos, lineNo = 1, lastWasNL = true
	      }

	fun getc (Stream {strm, pos, id, lineNo, ...}) = (case TSIO.input1 strm
              of NONE => NONE
	       | SOME (c, strm') => 
		   SOME (c, Stream {
			        strm = strm', 
				pos = pos+1, 
				id = id,
				lineNo = lineNo + 
					 (if c = #"\n" then 1 else 0),
				lastWasNL = (c = #"\n")
			      })
	     (* end case*))

	fun getpos (Stream {pos, ...}) = pos

	fun getlineNo (Stream {lineNo, ...}) = lineNo

	fun subtract (new, old) = let
	      val Stream {strm = strm, pos = oldPos, id = oldId, ...} = old
	      val Stream {pos = newPos, id = newId, ...} = new
              val (diff, _) = if newId = oldId andalso newPos >= oldPos
			      then TSIO.inputN (strm, newPos - oldPos)
			      else raise Fail 
				"BUG: yyInput: attempted to subtract incompatible streams"
	      in 
		diff 
	      end

	fun eof s = not (isSome (getc s))

	fun lastWasNL (Stream {lastWasNL, ...}) = lastWasNL

      end

    datatype yystart_state = 
STR | BYTE | SUFFIX | R_STR_END | BLOCK_COMMENT | INNER_LINE_DOC | BR_STR_BEGIN | OUTER_BLOCK_DOC | BYTE_STR | LINE_COMMENT | POUND | R_STR | LIFE_OR_CHAR | SHEBANG_OR_ATTR | INNER_BLOCK_DOC | BR_STR_BODY | OUTER_LINE_DOC | R_STR_BEGIN | R_STR_BODY | BR_STR | INITIAL | BR_STR_END
    structure UserDeclarations = 
      struct

(* rust.lex *)
(*
    Token list, for automatic completion.
    %term EOF
    | AS | BREAK | CONST | CONTINUE | CRATE | ELSE | ENUM | EXTERN     
        | FALSE | FN | FOR | IF | IMPL | IN | LET | LOOP | MATCH | MOD | MOVE
        | MUT | PUB | REF | RETURN | SELFVALUE | SELFTYPE | STATIC | STRUCT 
        | SUPER | TRAIT | TRUE | TYPE | UNSAFE | USE | WHERE | WHILE | DYN
    | ABSTRACT | BECOME | BOX | DO | FINAL | MACRO | OVERRIDE
        | PRIV | TYPEOF | UNSIZED | VIRTUAL | YIELD
        | ASYNC | AWAIT | TRY
    | UNION | STATICLIFETIME
    | IDENT of string
    | CHAR_LIT of int 
        | STR_LIT of string | RAW_STR_LIT of string
        | BYTE_LIT of int | BYTE_STR_LIT of string | RAW_BYTE_STR_LIT of string
        | INTEGER_LIT of LargeInt.int | TUPLE_INDEX of int 
        | FLOAT_LIT of real
    | LIFETIME of string
    | PLUS | MINUS | STAR | SLASH | PERCENT | CARET 
        | NOT | AND | OR | ANDAND | OROR | SHL | SHR
        | PLUSEQ | MINUSEQ | STAREQ | SLASHEQ | PERCENTEQ | CARETEQ | ANDEQ | OREQ
        | SHLEQ | SHREQ | EQ | EQEQ
        | NE | GT | LT | GE | LE
        | AT | UNDERSCORE | DOT | DOTDOT | DOTDOTDOT | DOTDOTEQ
        | COMMA | SEMI | COLON | PATHSEP | RARROW | FATARROW | POUND | DOLLAR | QUESTION
        | LBRACE | RBRACE | LBRACKET | RBRACKET | LPARENT | RPARENT
        | INNER_DOC_COMMENT of string | OUTER_DOC_COMMENT of string
        | SHEBANG
*)
(* 
    points:
    handle comments
    handle strings
    error handling
    end-of-file handling
    ...
*)
(*
    Input format: utf-8.
    Identifier: raw_identifier is not supported.
    Whitespace: Not include Characters 
                U+0085 (next line) 
                U+200E (left-to-right mark) 
                U+200F (right-to-left mark)
                U+2028 (line separator)
                U+2029 (paragraph separator)
    isolatedCR: A \r not followed by a \n, for some reasons, which is hard to be represented.
*)
(* user declarations *)
open Convert
type pos = int
type svalue = Tokens.svalue 
type ('a, 'b) token = ('a, 'b) Tokens.token
type lexresult = (svalue, pos) token
type lexarg = string
type arg = lexarg

val lin = ErrorMsg.lin
val col = ErrorMsg.col
val eolpos = ref 0
fun incLine(pos) = (lin := !lin+1; col := pos::(!col))

datatype comments = InnerBlock | OuterBlock | CommonBlock;
val stateStack:(comments*int) list ref = ref []
fun statePush(state, pos) = stateStack := (state, pos)::(!stateStack)
fun statePop(state):bool = case (!stateStack) of
                    (nil) => false
                    | ((h, _)::t) => if h = state then (stateStack := t;true) else false
val doc = ref ""
val docPos = ref 0
fun docInit(pos) = if null(!stateStack) then (doc:="";docPos:=pos;()) else (doc:=(!doc);docPos:=(!docPos);())

fun error(p1, p2) = ErrorMsg.error p1
fun lexLog(pos, msg) = ErrorMsg.lexLog (pos, msg)

val lsharp = ref 0
val rsharp = ref 0

val strList = ref (nil:char list)
val strpos = ref (0:int)
fun strAppend(s:char) = strList := s::(!strList)
fun strMake() = (implode(rev(!strList)))
fun strPop(nil, _) = nil 
    | strPop(h::t, 0) = h :: t 
    | strPop(h::t, n) = strPop(t, n-1)

fun strip(s, ch) = 
    let
        val chs = rev(String.explode s)
        fun remove(nil) = nil
            | remove(h::t) = if h = ch then remove(t) else h::t
    in
        implode (rev(remove(chs)))
    end

fun toChar(text:string) = 
    let
        val cc = String.explode (text)
        val c = hd(cc)
    in
        (* app print ["char literal: ", Char.toCString c, "\n"]; *)
        c
    end

fun escape(text:string, pos:int) = 
    let
        val chs = String.explode text

        fun hex2dec (nil, v) = v
            | hex2dec (#"a"::t, v) = hex2dec(t, v*16+10)
            | hex2dec (#"A"::t, v) = hex2dec(t, v*16+10)
            | hex2dec (#"b"::t, v) = hex2dec(t, v*16+11)
            | hex2dec (#"B"::t, v) = hex2dec(t, v*16+11)
            | hex2dec (#"c"::t, v) = hex2dec(t, v*16+12)
            | hex2dec (#"C"::t, v) = hex2dec(t, v*16+12)
            | hex2dec (#"d"::t, v) = hex2dec(t, v*16+13)
            | hex2dec (#"D"::t, v) = hex2dec(t, v*16+13)
            | hex2dec (#"e"::t, v) = hex2dec(t, v*16+14)
            | hex2dec (#"E"::t, v) = hex2dec(t, v*16+14)
            | hex2dec (#"f"::t, v) = hex2dec(t, v*16+15)
            | hex2dec (#"F"::t, v) = hex2dec(t, v*16+15)
            | hex2dec (h::t, v) = hex2dec(t, v*16+ (ord h) - (ord #"0"))
        
        fun unicode (nil, v) = v
            | unicode (#"{"::t, v) = unicode(t, v)
            | unicode (#"}"::t, v) = unicode(t, v)
            | unicode (#"_"::t, v) = unicode(t, v)
            | unicode (h::t, v) = unicode(t, v*16+ (ord h) - (ord #"0"))
        (* 
            This function convert char literal to a string for Char.fromString.
            However, Char.fromString can not work when unicode point is in ordinal range of the alphabet.
        *)
        fun convert (nil) = Char.ord #"\000"
            | convert (#"x"::t) = hex2dec(t, 0)
            | convert (#"u"::t) = unicode(t, 0)
            | convert (#"n"::t) = Char.ord #"\n"
            | convert (#"r"::t) = Char.ord #"\r"
            | convert (#"t"::t) = Char.ord #"\t"
            | convert (#"0"::t) = Char.ord #"\000"
            | convert (#"\092"::t) = Char.ord #"\092"
            | convert (#"'"::t) = Char.ord #"'"
            | convert (#"\""::t) = Char.ord #"\""
            | convert (h::t) = Char.ord (toChar(implode([#"\092", h])))
    in
        case chs of
        (#"\092"::t) => convert(t)
        | _ => (ErrorMsg.error pos ("illegal escape " ^ text);0)
    end

fun toInteger(text:string) = case LargeInt.fromString(text) of 
                            SOME v => v
                            | _ => 0
 
fun toFloat(text:string) = case Real.fromString(text) of 
                            SOME v => v
                            | _ => 0.0


fun eof(fileName:string) = 
    let 
        val pos = hd(!col)
    in 
        (
            case !stateStack of
            (nil) => ()
            | ((h, cpos)::t) => 
                ErrorMsg.error cpos "Comment block unclosed."
        );
        (
            if not (!lsharp = !rsharp) then
                    ErrorMsg.error (!strpos) "String unclosed."
            else ()
        );
        lexLog(pos, "Tokens.EOF");
        Tokens.EOF(pos, pos)
    end


      end

    datatype yymatch 
      = yyNO_MATCH
      | yyMATCH of yyInput.stream * action * yymatch
    withtype action = yyInput.stream * yymatch -> UserDeclarations.lexresult

    local

    val yytable = 
#[([(#"\^@",#"\t",21),
(#"\v",#"!",21),
(#"#",#"[",21),
(#"]",#"\255",21),
(#"\n",#"\n",22),
(#"\"",#"\"",23),
(#"\\",#"\\",24)], []), ([(#"\^@",#"\b",39),
(#"\v",#"\f",39),
(#"\^N",#"\^_",39),
(#"!",#"&",39),
(#"(",#"[",39),
(#"]",#"\127",39),
(#"\t",#"\t",40),
(#"\r",#"\r",40),
(#" ",#" ",40),
(#"'",#"'",40),
(#"\128",#"\255",40),
(#"\n",#"\n",41),
(#"\\",#"\\",42)], []), ([(#"\^@",#"@",52),
(#"[",#"^",52),
(#"`",#"`",52),
(#"{",#"\255",52),
(#"A",#"Z",53),
(#"_",#"_",53),
(#"a",#"z",53)], []), ([(#"\^@",#"\"",55),
(#"$",#"\255",55),
(#"#",#"#",56)], []), ([(#"\^@",#"\t",57),
(#"\v",#"\f",57),
(#"\^N",#")",57),
(#"+",#".",57),
(#"0",#"\255",57),
(#"\n",#"\n",58),
(#"\r",#"\r",59),
(#"*",#"*",60),
(#"/",#"/",61)], []), ([(#"\^@",#"\t",68),
(#"\v",#"\f",68),
(#"\^N",#"\255",68),
(#"\n",#"\n",69),
(#"\r",#"\r",70)], []), ([(#"\^@",#"\t",71),
(#"\v",#"!",71),
(#"$",#"\255",71),
(#"\n",#"\n",72),
(#"\"",#"\"",73),
(#"#",#"#",74)], []), ([(#"\^@",#"\t",75),
(#"\v",#"\f",75),
(#"\^N",#")",75),
(#"+",#".",75),
(#"0",#"\255",75),
(#"\n",#"\n",76),
(#"\r",#"\r",77),
(#"*",#"*",78),
(#"/",#"/",79)], []), ([(#"\^@",#"\b",81),
(#"\v",#"\f",81),
(#"\^N",#"\^_",81),
(#"!",#"!",81),
(#"#",#"[",81),
(#"]",#"\127",81),
(#"\t",#"\t",82),
(#"\r",#"\r",82),
(#" ",#" ",82),
(#"\128",#"\255",82),
(#"\n",#"\n",83),
(#"\"",#"\"",84),
(#"\\",#"\\",85)], []), ([(#"\^@",#"\t",91),
(#"\v",#"\255",91),
(#"\n",#"\n",92)], []), ([], []), ([(#"\^@",#"\t",93),
(#"\v",#"!",93),
(#"#",#"\255",93),
(#"\n",#"\n",94),
(#"\"",#"\"",95)], []), ([(#"\^@",#"\t",96),
(#"\v",#"@",96),
(#"[",#"[",96),
(#"]",#"^",96),
(#"`",#"`",96),
(#"{",#"\127",96),
(#"A",#"Z",97),
(#"_",#"_",97),
(#"a",#"z",97),
(#"\\",#"\\",98),
(#"\128",#"\255",99)], []), ([(#"\^@",#"\t",123),
(#"\v",#"\f",123),
(#"\^N",#")",123),
(#"+",#".",123),
(#"0",#"\255",123),
(#"\n",#"\n",124),
(#"\r",#"\r",125),
(#"*",#"*",126),
(#"/",#"/",127)], []), ([(#"\^@",#"\t",129),
(#"\v",#"!",129),
(#"#",#"\127",129),
(#"\n",#"\n",130),
(#"\"",#"\"",131),
(#"\128",#"\255",132)], []), ([(#"\^@",#"\t",134),
(#"\v",#"\f",134),
(#"\^N",#"\255",134),
(#"\n",#"\n",135),
(#"\r",#"\r",136)], []), ([(#"\^@",#"\t",137),
(#"\v",#"!",137),
(#"$",#"\255",137),
(#"\n",#"\n",138),
(#"\"",#"\"",139),
(#"#",#"#",140)], []), ([(#"\^@",#"\t",141),
(#"\v",#"!",141),
(#"#",#"\255",141),
(#"\n",#"\n",142),
(#"\"",#"\"",143)], []), ([(#"\^@",#"\t",145),
(#"\v",#"!",145),
(#"#",#"\127",145),
(#"\n",#"\n",146),
(#"\"",#"\"",147),
(#"\128",#"\255",148)], []), ([(#"\^@",#"\b",149),
(#"\v",#"\f",149),
(#"\^N",#"\^_",149),
(#"\\",#"\\",149),
(#"`",#"`",149),
(#"~",#"\238",149),
(#"\240",#"\255",149),
(#"\t",#"\t",150),
(#" ",#" ",150),
(#"\n",#"\n",151),
(#"\r",#"\r",152),
(#"!",#"!",153),
(#"\"",#"\"",154),
(#"#",#"#",155),
(#"$",#"$",156),
(#"%",#"%",157),
(#"&",#"&",158),
(#"'",#"'",159),
(#"(",#"(",160),
(#")",#")",161),
(#"*",#"*",162),
(#"+",#"+",163),
(#",",#",",164),
(#"-",#"-",165),
(#".",#".",166),
(#"/",#"/",167),
(#"0",#"0",168),
(#"1",#"9",169),
(#":",#":",170),
(#";",#";",171),
(#"<",#"<",172),
(#"=",#"=",173),
(#">",#">",174),
(#"?",#"?",175),
(#"@",#"@",176),
(#"A",#"R",177),
(#"T",#"Z",177),
(#"g",#"h",177),
(#"j",#"k",177),
(#"n",#"n",177),
(#"q",#"q",177),
(#"x",#"x",177),
(#"z",#"z",177),
(#"S",#"S",178),
(#"[",#"[",179),
(#"]",#"]",180),
(#"^",#"^",181),
(#"_",#"_",182),
(#"a",#"a",183),
(#"b",#"b",184),
(#"c",#"c",185),
(#"d",#"d",186),
(#"e",#"e",187),
(#"f",#"f",188),
(#"i",#"i",189),
(#"l",#"l",190),
(#"m",#"m",191),
(#"o",#"o",192),
(#"p",#"p",193),
(#"r",#"r",194),
(#"s",#"s",195),
(#"t",#"t",196),
(#"u",#"u",197),
(#"v",#"v",198),
(#"w",#"w",199),
(#"y",#"y",200),
(#"{",#"{",201),
(#"|",#"|",202),
(#"}",#"}",203),
(#"\239",#"\239",204)], [1]), ([(#"\^@",#"\"",438),
(#"$",#"\255",438),
(#"#",#"#",439)], []), ([], [99]), ([], [98]), ([], [93, 99]), ([(#"\n",#"\n",25),
(#" ",#" ",26),
(#"0",#"0",26),
(#"\\",#"\\",26),
(#"n",#"n",26),
(#"r",#"r",26),
(#"t",#"t",26),
(#"\"",#"\"",27),
(#"'",#"'",27),
(#"u",#"u",28),
(#"x",#"x",29)], [99]), ([], [97]), ([], [95]), ([], [94]), ([(#"{",#"{",31)], []), ([(#"0",#"7",30)], []), ([(#"0",#"9",26),
(#"A",#"F",26),
(#"a",#"f",26)], []), ([(#"0",#"9",32),
(#"A",#"F",32),
(#"a",#"f",32)], []), ([(#"0",#"9",33),
(#"A",#"F",33),
(#"a",#"f",33),
(#"_",#"_",32),
(#"}",#"}",34)], []), ([(#"0",#"9",35),
(#"A",#"F",35),
(#"a",#"f",35),
(#"_",#"_",33),
(#"}",#"}",34)], []), ([], [96]), ([(#"0",#"9",36),
(#"A",#"F",36),
(#"a",#"f",36),
(#"_",#"_",35),
(#"}",#"}",34)], []), ([(#"0",#"9",37),
(#"A",#"F",37),
(#"a",#"f",37),
(#"_",#"_",36),
(#"}",#"}",34)], []), ([(#"0",#"9",38),
(#"A",#"F",38),
(#"a",#"f",38),
(#"_",#"_",37),
(#"}",#"}",34)], []), ([(#"_",#"_",38),
(#"}",#"}",34)], []), ([(#"'",#"'",51)], []), ([(#"'",#"'",50)], []), ([(#"'",#"'",49)], []), ([(#" ",#" ",43),
(#"0",#"0",43),
(#"\\",#"\\",43),
(#"n",#"n",43),
(#"r",#"r",43),
(#"t",#"t",43),
(#"'",#"'",44),
(#"x",#"x",45)], []), ([(#"'",#"'",48)], []), ([(#"'",#"'",47)], [119]), ([(#"0",#"9",46),
(#"A",#"F",46),
(#"a",#"f",46)], []), ([(#"0",#"9",43),
(#"A",#"F",43),
(#"a",#"f",43)], []), ([], [115]), ([], [116]), ([], [118]), ([], [119]), ([], [117, 119]), ([], [28, 29]), ([(#"0",#"9",54),
(#"A",#"Z",54),
(#"_",#"_",54),
(#"a",#"z",54)], [27, 28, 29]), ([(#"0",#"9",54),
(#"A",#"Z",54),
(#"_",#"_",54),
(#"a",#"z",54)], [27]), ([], [113]), ([], [112]), ([], [24]), ([], [21]), ([(#"\n",#"\n",58)], [21, 24]), ([(#"/",#"/",67)], [24]), ([(#"*",#"*",62)], [24]), ([(#"!",#"!",63),
(#"*",#"*",64)], [19]), ([], [14]), ([(#"*",#"*",65),
(#"/",#"/",66)], [17]), ([(#"/",#"/",66)], [19]), ([], [16]), ([], [20]), ([], [7]), ([], [6]), ([(#"\n",#"\n",69)], [6, 7]), ([], [137]), ([], [136]), ([], [135, 137]), ([], [134, 137]), ([], [26]), ([], [23]), ([(#"\n",#"\n",76)], [23, 26]), ([(#"/",#"/",80)], [26]), ([(#"*",#"*",62)], [26]), ([], [18]), ([], [122, 127]), ([], [127]), ([], [126]), ([], [121, 127]), ([(#"\n",#"\n",86),
(#" ",#" ",87),
(#"0",#"0",87),
(#"\\",#"\\",87),
(#"n",#"n",87),
(#"r",#"r",87),
(#"t",#"t",87),
(#"\"",#"\"",88),
(#"x",#"x",89)], [122, 127]), ([], [125]), ([], [124]), ([], [123]), ([(#"0",#"9",90),
(#"A",#"F",90),
(#"a",#"f",90)], []), ([(#"0",#"9",87),
(#"A",#"F",87),
(#"a",#"f",87)], []), ([], [13]), ([], [12]), ([], [103]), ([], [102]), ([], [101, 103]), ([(#"'",#"'",100)], []), ([(#"'",#"'",100),
(#"0",#"9",122),
(#"A",#"Z",122),
(#"_",#"_",122),
(#"a",#"z",122)], [86]), ([(#" ",#" ",105),
(#"0",#"0",105),
(#"\\",#"\\",105),
(#"n",#"n",105),
(#"r",#"r",105),
(#"t",#"t",105),
(#"\"",#"\"",106),
(#"'",#"'",107),
(#"u",#"u",108),
(#"x",#"x",109)], []), ([(#"'",#"'",100),
(#"\128",#"\255",101)], []), ([], [90]), ([(#"'",#"'",102),
(#"\128",#"\255",103)], []), ([], [91]), ([(#"'",#"'",102),
(#"\128",#"\255",104)], []), ([(#"'",#"'",102)], []), ([(#"'",#"'",121)], []), ([(#"'",#"'",120)], []), ([(#"'",#"'",120)], [90]), ([(#"{",#"{",111)], []), ([(#"0",#"7",110)], []), ([(#"0",#"9",105),
(#"A",#"F",105),
(#"a",#"f",105)], []), ([(#"0",#"9",112),
(#"A",#"F",112),
(#"a",#"f",112)], []), ([(#"0",#"9",113),
(#"A",#"F",113),
(#"a",#"f",113),
(#"_",#"_",112),
(#"}",#"}",114)], []), ([(#"0",#"9",116),
(#"A",#"F",116),
(#"a",#"f",116),
(#"_",#"_",113),
(#"}",#"}",114)], []), ([(#"'",#"'",115)], []), ([], [89]), ([(#"0",#"9",117),
(#"A",#"F",117),
(#"a",#"f",117),
(#"_",#"_",116),
(#"}",#"}",114)], []), ([(#"0",#"9",118),
(#"A",#"F",118),
(#"a",#"f",118),
(#"_",#"_",117),
(#"}",#"}",114)], []), ([(#"0",#"9",119),
(#"A",#"F",119),
(#"a",#"f",119),
(#"_",#"_",118),
(#"}",#"}",114)], []), ([(#"_",#"_",119),
(#"}",#"}",114)], []), ([], [87]), ([], [88]), ([(#"0",#"9",122),
(#"A",#"Z",122),
(#"_",#"_",122),
(#"a",#"z",122)], [86]), ([], [25]), ([], [22]), ([(#"\n",#"\n",124)], [22, 25]), ([(#"/",#"/",128)], [25]), ([(#"*",#"*",62)], [25]), ([], [15]), ([], [140, 141]), ([], [139, 140]), ([(#"#",#"#",133)], [140, 141]), ([], [141]), ([], [138]), ([], [10]), ([], [9]), ([(#"\n",#"\n",135)], [9, 10]), ([], [108]), ([], [107]), ([], [106, 108]), ([], [105, 108]), ([], [111]), ([], [110]), ([(#"#",#"#",144)], [111]), ([], [109]), ([], [131, 132]), ([], [130, 131]), ([], [129, 131, 132]), ([], [132]), ([], [196]), ([(#"\t",#"\t",437),
(#" ",#" ",437)], [1, 196]), ([], [0]), ([(#"\n",#"\n",151)], [0, 196]), ([(#"=",#"=",436)], [178, 196]), ([], [92, 196]), ([(#"!",#"!",433)], [176, 196]), ([], [188, 196]), ([(#"=",#"=",432)], [175, 196]), ([(#"&",#"&",430),
(#"=",#"=",431)], [179, 196]), ([], [84, 196]), ([], [194, 196]), ([], [195, 196]), ([(#"=",#"=",429)], [173, 196]), ([(#"=",#"=",428)], [171, 196]), ([], [185, 196]), ([(#"=",#"=",426),
(#">",#">",427)], [172, 196]), ([(#".",#".",423)], [170, 196]), ([(#"*",#"*",62),
(#"/",#"/",418),
(#"=",#"=",419)], [174, 196]), ([(#".",#".",393),
(#"0",#"9",394),
(#"_",#"_",394),
(#"E",#"E",395),
(#"e",#"e",395),
(#"b",#"b",412),
(#"f",#"f",396),
(#"i",#"i",397),
(#"u",#"u",397),
(#"o",#"o",413),
(#"x",#"x",414)], [144, 196]), ([(#".",#".",393),
(#"0",#"9",394),
(#"_",#"_",394),
(#"E",#"E",395),
(#"e",#"e",395),
(#"f",#"f",396),
(#"i",#"i",397),
(#"u",#"u",397)], [144, 196]), ([(#":",#":",392)], [187, 196]), ([], [186, 196]), ([(#"<",#"<",389),
(#"=",#"=",390)], [183, 196]), ([(#"=",#"=",387),
(#">",#">",388)], [181, 196]), ([(#"=",#"=",384),
(#">",#">",385)], [182, 196]), ([], [189, 196]), ([], [184, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",381)], [83, 196]), ([], [192, 196]), ([], [193, 196]), ([(#"=",#"=",380)], [177, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [30, 83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"a",209),
(#"c",#"r",209),
(#"t",#"v",209),
(#"x",#"z",209),
(#"b",#"b",365),
(#"s",#"s",366),
(#"w",#"w",367)], [83, 196]), ([(#"\"",#"\"",350),
(#"'",#"'",351),
(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"n",209),
(#"p",#"q",209),
(#"s",#"z",209),
(#"e",#"e",352),
(#"o",#"o",353),
(#"r",#"r",354)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"q",209),
(#"s",#"z",209),
(#"o",#"o",337),
(#"r",#"r",338)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"x",209),
(#"z",#"z",209),
(#"o",#"o",334),
(#"y",#"y",335)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"m",209),
(#"o",#"w",209),
(#"y",#"z",209),
(#"l",#"l",323),
(#"n",#"n",324),
(#"x",#"x",325)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"h",209),
(#"j",#"m",209),
(#"p",#"z",209),
(#"a",#"a",312),
(#"i",#"i",313),
(#"n",#"n",314),
(#"o",#"o",315)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"l",209),
(#"o",#"z",209),
(#"f",#"f",307),
(#"m",#"m",308),
(#"n",#"n",309)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"n",209),
(#"p",#"z",209),
(#"e",#"e",302),
(#"o",#"o",303)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"n",209),
(#"p",#"t",209),
(#"v",#"z",209),
(#"a",#"a",289),
(#"o",#"o",290),
(#"u",#"u",291)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"u",209),
(#"w",#"z",209),
(#"v",#"v",282)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"t",209),
(#"v",#"z",209),
(#"r",#"r",277),
(#"u",#"u",278)], [83, 196]), ([(#"\"",#"\"",269),
(#"#",#"#",270),
(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",271)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"s",209),
(#"v",#"z",209),
(#"e",#"e",253),
(#"t",#"t",254),
(#"u",#"u",255)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"x",209),
(#"z",#"z",209),
(#"r",#"r",241),
(#"y",#"y",242)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"r",209),
(#"t",#"z",209),
(#"n",#"n",227),
(#"s",#"s",228)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",221)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"g",209),
(#"i",#"z",209),
(#"h",#"h",214)], [83, 196]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",210)], [83, 196]), ([], [190, 196]), ([(#"=",#"=",207),
(#"|",#"|",208)], [180, 196]), ([], [191, 196]), ([(#"\189",#"\189",205)], [196]), ([(#"\191",#"\191",206)], []), ([], [2]), ([], [161]), ([], [151]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",211)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",212)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"c",209),
(#"e",#"z",209),
(#"d",#"d",213)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [78, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"h",209),
(#"j",#"z",209),
(#"e",#"e",215),
(#"i",#"i",216)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",219)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",217)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",218)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [65, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",220)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [64, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",222)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",223)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"t",209),
(#"v",#"z",209),
(#"u",#"u",224)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",225)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",226)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [77, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"r",209),
(#"t",#"z",209),
(#"i",#"i",230),
(#"s",#"s",231)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",229)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [63, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"z",209),
(#"o",#"o",239)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"h",209),
(#"j",#"z",209),
(#"a",#"a",232),
(#"i",#"i",233)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"z",209),
(#"f",#"f",237)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"y",209),
(#"z",#"z",234)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",235)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"c",209),
(#"e",#"z",209),
(#"d",#"d",236)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [76, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",238)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [62, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",240)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [82, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"t",209),
(#"v",#"x",209),
(#"z",#"z",209),
(#"a",#"a",247),
(#"u",#"u",248),
(#"y",#"y",249)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"o",209),
(#"q",#"z",209),
(#"p",#"p",243)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",244)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"z",209),
(#"o",#"o",245)], [61, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"z",209),
(#"f",#"f",246)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [75, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",251)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",250)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [81, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [60, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",252)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [59, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",267)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"q",209),
(#"s",#"z",209),
(#"a",#"a",259),
(#"r",#"r",260)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"o",209),
(#"q",#"z",209),
(#"p",#"p",256)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",257)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",258)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [58, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",264)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"t",209),
(#"v",#"z",209),
(#"u",#"u",261)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",262)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",263)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [57, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",265)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",266)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [56, 83, 85]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"z",209),
(#"f",#"f",268)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [54, 83]), ([], [100]), ([], [104]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"s",209),
(#"u",#"z",209),
(#"f",#"f",272),
(#"t",#"t",273)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [52, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"t",209),
(#"v",#"z",209),
(#"u",#"u",274)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",275)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",276)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [53, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",280)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"a",209),
(#"c",#"z",209),
(#"b",#"b",279)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [51, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"u",209),
(#"w",#"z",209),
(#"v",#"v",281)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [74, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",283)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",284)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",285)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",286)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"c",209),
(#"e",#"z",209),
(#"d",#"d",287)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",288)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [73, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"s",209),
(#"u",#"z",209),
(#"c",#"c",296),
(#"t",#"t",297)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"c",209),
(#"e",#"u",209),
(#"w",#"z",209),
(#"d",#"d",293),
(#"v",#"v",294)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",292)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [50, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [48, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",295)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [49, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",300)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",298)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"g",209),
(#"i",#"z",209),
(#"h",#"h",299)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [47, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"z",209),
(#"o",#"o",301)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [72, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",306)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"z",209),
(#"o",#"o",304)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"o",209),
(#"q",#"z",209),
(#"p",#"p",305)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [46, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [45, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [42, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"o",209),
(#"q",#"z",209),
(#"p",#"p",310)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [44, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",311)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [43, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",320)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",317)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [40, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",316)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [41, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",318)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",319)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [71, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"r",209),
(#"t",#"z",209),
(#"s",#"s",321)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",322)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [39, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"r",209),
(#"t",#"z",209),
(#"s",#"s",332)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"t",209),
(#"v",#"z",209),
(#"u",#"u",330)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",326)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",327)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",328)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",329)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [38, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"l",209),
(#"n",#"z",209),
(#"m",#"m",331)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [37, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",333)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [36, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [70, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",336)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [66, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",342)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",339)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",340)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",341)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [35, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"r",209),
(#"u",#"z",209),
(#"s",#"s",343),
(#"t",#"t",344)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",349)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",345)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",346)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"t",209),
(#"v",#"z",209),
(#"u",#"u",347)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",348)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [34, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [33, 83]), ([], [120]), ([], [114]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",361)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"w",209),
(#"y",#"z",209),
(#"x",#"x",360)], [83]), ([(#"\"",#"\"",355),
(#"#",#"#",356),
(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",357)], [83]), ([], [128]), ([], [133]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",358)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"j",209),
(#"l",#"z",209),
(#"k",#"k",359)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [32, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [69, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"n",209),
(#"p",#"z",209),
(#"o",#"o",362)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"l",209),
(#"n",#"z",209),
(#"m",#"m",363)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"d",209),
(#"f",#"z",209),
(#"e",#"e",364)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [68, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"r",209),
(#"t",#"z",209),
(#"s",#"s",374)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"x",209),
(#"z",#"z",209),
(#"y",#"y",371)], [31, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",368)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"h",209),
(#"j",#"z",209),
(#"i",#"i",369)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",370)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [80, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"m",209),
(#"o",#"z",209),
(#"n",#"n",372)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",373)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [79, 83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",375)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"q",209),
(#"s",#"z",209),
(#"r",#"r",376)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"b",#"z",209),
(#"a",#"a",377)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"b",209),
(#"d",#"z",209),
(#"c",#"c",378)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"s",209),
(#"u",#"z",209),
(#"t",#"t",379)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [67, 83]), ([], [159]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"k",209),
(#"m",#"z",209),
(#"l",#"l",382)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"e",209),
(#"g",#"z",209),
(#"f",#"f",383)], [83]), ([(#"0",#"9",209),
(#"A",#"Z",209),
(#"_",#"_",209),
(#"a",#"z",209)], [55, 83]), ([], [164]), ([(#"=",#"=",386)], [153]), ([], [147]), ([], [162]), ([], [167]), ([(#"=",#"=",391)], [152]), ([], [165]), ([], [146]), ([], [169]), ([(#"0",#"9",411)], [145]), ([(#".",#".",393),
(#"0",#"9",394),
(#"_",#"_",394),
(#"E",#"E",395),
(#"e",#"e",395),
(#"f",#"f",396),
(#"i",#"i",397),
(#"u",#"u",397)], [144]), ([(#"+",#"+",409),
(#"-",#"-",409),
(#"_",#"_",409),
(#"0",#"9",410)], []), ([(#"3",#"3",406),
(#"6",#"6",407)], []), ([(#"1",#"1",398),
(#"3",#"3",399),
(#"6",#"6",400),
(#"8",#"8",401),
(#"s",#"s",402)], []), ([(#"2",#"2",405),
(#"6",#"6",401)], []), ([(#"2",#"2",401)], []), ([(#"4",#"4",401)], []), ([], [144]), ([(#"i",#"i",403)], []), ([(#"z",#"z",404)], []), ([(#"e",#"e",401)], []), ([(#"8",#"8",401)], []), ([(#"2",#"2",408)], []), ([(#"4",#"4",408)], []), ([], [145]), ([(#"0",#"9",410),
(#"_",#"_",409)], []), ([(#"0",#"9",410),
(#"_",#"_",410),
(#"f",#"f",396)], [145]), ([(#"0",#"9",411),
(#"_",#"_",411),
(#"E",#"E",395),
(#"e",#"e",395),
(#"f",#"f",396)], [145]), ([(#"0",#"1",417),
(#"_",#"_",412)], []), ([(#"0",#"7",416),
(#"_",#"_",413)], []), ([(#"0",#"9",415),
(#"A",#"F",415),
(#"a",#"f",415),
(#"_",#"_",414)], []), ([(#"0",#"9",415),
(#"A",#"F",415),
(#"_",#"_",415),
(#"a",#"f",415),
(#"i",#"i",397),
(#"u",#"u",397)], [144]), ([(#"0",#"7",416),
(#"_",#"_",416),
(#"i",#"i",397),
(#"u",#"u",397)], [144]), ([(#"0",#"1",417),
(#"_",#"_",417),
(#"i",#"i",397),
(#"u",#"u",397)], [144]), ([(#"!",#"!",420),
(#"/",#"/",421)], [11]), ([], [157]), ([], [5]), ([(#"/",#"/",422)], [8]), ([], [11]), ([(#".",#".",424),
(#"=",#"=",425)], [168]), ([], [148]), ([], [149]), ([], [155]), ([], [166]), ([], [154]), ([], [156]), ([], [150]), ([], [160]), ([], [158]), ([(#"\^@",#"\t",434),
(#"\v",#"Z",434),
(#"\\",#"\255",434),
(#"\n",#"\n",435)], [4]), ([(#"\^@",#"\t",434),
(#"\v",#"Z",434),
(#"\\",#"\255",434),
(#"\n",#"\n",435)], []), ([], [3]), ([], [163]), ([(#"\t",#"\t",437),
(#" ",#" ",437)], [1]), ([], [143]), ([], [142])]
    fun mk yyins = let
        (* current start state *)
        val yyss = ref INITIAL
	fun YYBEGIN ss = (yyss := ss)
	(* current input stream *)
        val yystrm = ref yyins
	(* get one char of input *)
	val yygetc = yyInput.getc
	(* create yytext *)
	fun yymktext(strm) = yyInput.subtract (strm, !yystrm)
        open UserDeclarations
        fun lex 
(yyarg as (fileName:string)) () = let 
     fun continue() = let
            val yylastwasn = yyInput.lastWasNL (!yystrm)
            fun yystuck (yyNO_MATCH) = raise Fail "stuck state"
	      | yystuck (yyMATCH (strm, action, old)) = 
		  action (strm, old)
	    val yypos = yyInput.getpos (!yystrm)
	    val yygetlineNo = yyInput.getlineNo
	    fun yyactsToMatches (strm, [],	  oldMatches) = oldMatches
	      | yyactsToMatches (strm, act::acts, oldMatches) = 
		  yyMATCH (strm, act, yyactsToMatches (strm, acts, oldMatches))
	    fun yygo actTable = 
		(fn (~1, _, oldMatches) => yystuck oldMatches
		  | (curState, strm, oldMatches) => let
		      val (transitions, finals') = Vector.sub (yytable, curState)
		      val finals = List.map (fn i => Vector.sub (actTable, i)) finals'
		      fun tryfinal() = 
		            yystuck (yyactsToMatches (strm, finals, oldMatches))
		      fun find (c, []) = NONE
			| find (c, (c1, c2, s)::ts) = 
		            if c1 <= c andalso c <= c2 then SOME s
			    else find (c, ts)
		      in case yygetc strm
			  of SOME(c, strm') => 
			       (case find (c, transitions)
				 of NONE => tryfinal()
				  | SOME n => 
				      yygo actTable
					(n, strm', 
					 yyactsToMatches (strm, finals, oldMatches)))
			   | NONE => tryfinal()
		      end)
	    in 
let
fun yyAction0 (strm, lastMatch : yymatch) = (yystrm := strm;
      (incLine(yypos); continue()))
fun yyAction1 (strm, lastMatch : yymatch) = (yystrm := strm; (continue()))
fun yyAction2 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                        (if not (!lin = 1) then
                                            ErrorMsg.error yypos ("Unexpected utf8 bom [INITIAL] " ^ yytext)
                                        else ());
                                        continue()
                                    )
      end
fun yyAction3 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                    (* 
                                        Shebang line should occur at the first line.
                                        If not, just continue and report message.
                                    *)
                                    if (!lin = 1) then(
                                        lin := !lin + 1;
                                        lexLog(yypos, "<Shebang line>: "^yytext);
                                        Tokens.SHEBANG_LINE(strip(yytext, #"\n"), yypos, yypos+size yytext)
                                    )
                                    else (
                                        lin := !lin + 1;
                                        ErrorMsg.error yypos "Illegal Shebang line.";
                                        continue()
                                    )
                                    )
      end
fun yyAction4 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Token.SHEBANG"); Tokens.SHEBANG(yypos, yypos+ size yytext))
      end
fun yyAction5 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "INNER_LINE_DOC"); docInit(yypos); YYBEGIN INNER_LINE_DOC; continue()))
fun yyAction6 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                        lexLog(yypos, "INNER_DOC_COMMENT: "^(!doc)); 
                                        YYBEGIN INITIAL; 
                                        incLine(yypos);
                                        Tokens.INNER_DOC_COMMENT(!doc, !docPos, yypos)
                                    ))
fun yyAction7 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; continue())
      end
fun yyAction8 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "OUTER_LINE_DOC"); docInit(yypos); YYBEGIN OUTER_LINE_DOC; continue()))
fun yyAction9 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                        lexLog(yypos, "OUTER_DOC_COMMENT: "^(!doc)); 
                                        YYBEGIN INITIAL;
                                        incLine(yypos);
                                        Tokens.OUTER_DOC_COMMENT(!doc, !docPos, yypos)
                                    ))
fun yyAction10 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; continue())
      end
fun yyAction11 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "LINE_COMMENT"); YYBEGIN LINE_COMMENT; continue()))
fun yyAction12 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; incLine(yypos);  continue()))
fun yyAction13 (strm, lastMatch : yymatch) = (yystrm := strm; (continue()))
fun yyAction14 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "INNER_BLOCK_DOC"); 
                                    docInit(yypos);
                                    YYBEGIN INNER_BLOCK_DOC; 
                                    statePush(InnerBlock, yypos); 
                                    continue()
                                    ))
fun yyAction15 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                    (
                                        if not (statePop(InnerBlock)) then
                                            ErrorMsg.error yypos "INNER_BLOCK_DOC does not match."
                                        else ()
                                    );
                                    (
                                        case (!stateStack) 
                                            of (nil) => ((lexLog(yypos, "INNER_DOC_COMMENT: "^(!doc))); YYBEGIN INITIAL)
                                            | ((CommonBlock, _)::t) => YYBEGIN BLOCK_COMMENT
                                            | ((InnerBlock, _)::t) => YYBEGIN INNER_BLOCK_DOC
                                            | ((OuterBlock, _)::t) => YYBEGIN OUTER_BLOCK_DOC
                                    );
                                    if null(!stateStack) then 
                                    Tokens.INNER_DOC_COMMENT(!doc, !docPos, yypos)
                                    else continue()
                                ))
fun yyAction16 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "BLOCK_COMMENT"); continue()))
fun yyAction17 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                    lexLog(yypos, "OUTER_BLOCK_DOC"); 
                                    docInit(yypos); 
                                    YYBEGIN OUTER_BLOCK_DOC; 
                                    statePush(OuterBlock, yypos);
                                    continue()
                                    ))
fun yyAction18 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                        (
                                            if not (statePop(OuterBlock)) then
                                                ErrorMsg.error yypos "OUTER_BLOCK_DOC does not match."
                                            else ()
                                        );
                                        (
                                           case (!stateStack) 
                                                of (nil) => ((lexLog(yypos, "OUTER_DOC_COMMENT: "^(!doc))); YYBEGIN INITIAL)
                                                | ((CommonBlock, _)::t) => YYBEGIN BLOCK_COMMENT
                                                | ((InnerBlock, _)::t) => YYBEGIN INNER_BLOCK_DOC
                                                | ((OuterBlock, _)::t) => YYBEGIN OUTER_BLOCK_DOC
                                        );
                                        if null(!stateStack) then 
                                            Tokens.OUTER_DOC_COMMENT(!doc, !docPos, yypos)
                                        else continue()
                                    ))
fun yyAction19 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "BLOCK_COMMENT"); YYBEGIN BLOCK_COMMENT; statePush(CommonBlock, yypos); continue()))
fun yyAction20 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                         (
                                            if not (statePop(CommonBlock)) then
                                                ErrorMsg.error yypos "BLOCK_COMMENT does not match."
                                            else ()
                                        );
                                        (
                                            case (!stateStack) 
                                                of (nil) => YYBEGIN INITIAL
                                                | ((CommonBlock, _)::t) => YYBEGIN BLOCK_COMMENT
                                                | ((InnerBlock, _)::t) => YYBEGIN INNER_BLOCK_DOC
                                                | ((OuterBlock, _)::t) => YYBEGIN OUTER_BLOCK_DOC

                                        );
                                        continue()
                                    ))
fun yyAction21 (strm, lastMatch : yymatch) = (yystrm := strm;
      (incLine(yypos);  continue()))
fun yyAction22 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; incLine(yypos);  continue())
      end
fun yyAction23 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; incLine(yypos);  continue())
      end
fun yyAction24 (strm, lastMatch : yymatch) = (yystrm := strm; (continue()))
fun yyAction25 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; continue())
      end
fun yyAction26 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (doc:=(!doc)^yytext; continue())
      end
fun yyAction27 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; continue()))
fun yyAction28 (strm, lastMatch : yymatch) = let
      val oldStrm = !(yystrm)
      fun REJECT () = (yystrm := oldStrm; yystuck(lastMatch))
      in
        yystrm := strm; (YYBEGIN INITIAL; REJECT())
      end
fun yyAction29 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "break"); YYBEGIN INITIAL; continue()))
fun yyAction30 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation>"^yytext); Tokens.UNDERSCORE(yypos, yypos+size yytext))
      end
fun yyAction31 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.AS(yypos, yypos+size yytext))
      end
fun yyAction32 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.BREAK(yypos, yypos+size yytext))
      end
fun yyAction33 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.CONST(yypos, yypos+size yytext))
      end
fun yyAction34 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.CONTINUE(yypos, yypos+size yytext))
      end
fun yyAction35 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.CARET(yypos, yypos+size yytext))
      end
fun yyAction36 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.ELSE(yypos, yypos+size yytext))
      end
fun yyAction37 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.ENUM(yypos, yypos+size yytext))
      end
fun yyAction38 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.EXTERN(yypos, yypos+size yytext))
      end
fun yyAction39 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.FALSE(yypos, yypos+size yytext))
      end
fun yyAction40 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.FN(yypos, yypos+size yytext))
      end
fun yyAction41 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.FOR(yypos, yypos+size yytext))
      end
fun yyAction42 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.IF(yypos, yypos+size yytext))
      end
fun yyAction43 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.IMPL(yypos, yypos+size yytext))
      end
fun yyAction44 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.IN(yypos, yypos+size yytext))
      end
fun yyAction45 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.LET(yypos, yypos+size yytext))
      end
fun yyAction46 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.LOOP(yypos, yypos+size yytext))
      end
fun yyAction47 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.MATCH(yypos, yypos+size yytext))
      end
fun yyAction48 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.MOD(yypos, yypos+size yytext))
      end
fun yyAction49 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.MOVE(yypos, yypos+size yytext))
      end
fun yyAction50 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.MUT(yypos, yypos+size yytext))
      end
fun yyAction51 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.PUB(yypos, yypos+size yytext))
      end
fun yyAction52 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.REF(yypos, yypos+size yytext))
      end
fun yyAction53 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.RETURN(yypos, yypos+size yytext))
      end
fun yyAction54 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.SELFVALUE(yypos, yypos+size yytext))
      end
fun yyAction55 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.SELFTYPE(yypos, yypos+size yytext))
      end
fun yyAction56 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.STATIC(yypos, yypos+size yytext))
      end
fun yyAction57 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.STRUCT(yypos, yypos+size yytext))
      end
fun yyAction58 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.SUPER(yypos, yypos+size yytext))
      end
fun yyAction59 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.TRAIT(yypos, yypos+size yytext))
      end
fun yyAction60 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.TRUE(yypos, yypos+size yytext))
      end
fun yyAction61 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.TYPE(yypos, yypos+size yytext))
      end
fun yyAction62 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.UNSAFE(yypos, yypos+size yytext))
      end
fun yyAction63 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.USE(yypos, yypos+size yytext))
      end
fun yyAction64 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.WHERE(yypos, yypos+size yytext))
      end
fun yyAction65 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.WHILE(yypos, yypos+size yytext))
      end
fun yyAction66 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.DYN(yypos, yypos+size yytext))
      end
fun yyAction67 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.ABSTRACT(yypos, yypos+size yytext))
      end
fun yyAction68 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.BECOME(yypos, yypos+size yytext))
      end
fun yyAction69 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.BOX(yypos, yypos+size yytext))
      end
fun yyAction70 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.DO(yypos, yypos+size yytext))
      end
fun yyAction71 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.FINAL(yypos, yypos+size yytext))
      end
fun yyAction72 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.MACRO(yypos, yypos+size yytext))
      end
fun yyAction73 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.OVERRIDE(yypos, yypos+size yytext))
      end
fun yyAction74 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.PRIV(yypos, yypos+size yytext))
      end
fun yyAction75 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.TYPEOF(yypos, yypos+size yytext))
      end
fun yyAction76 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.UNSIZED(yypos, yypos+size yytext))
      end
fun yyAction77 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.VIRTUAL(yypos, yypos+size yytext))
      end
fun yyAction78 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.YIELD(yypos, yypos+size yytext))
      end
fun yyAction79 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.ASYNC(yypos, yypos+size yytext))
      end
fun yyAction80 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.AWAIT(yypos, yypos+size yytext))
      end
fun yyAction81 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.TRY(yypos, yypos+size yytext))
      end
fun yyAction82 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, yytext); Tokens.UNION(yypos, yypos+size yytext))
      end
fun yyAction83 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.IDENT "^yytext); Tokens.IDENT(yytext, yypos, yypos+size yytext))
      end
fun yyAction84 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN LIFE_OR_CHAR; lexLog(yypos, "<Char>"); continue()))
fun yyAction85 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext); Tokens.STATICLIFETIME(yypos, yypos+size yytext))
      end
fun yyAction86 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext);
                                        (* lifetime_token or loop_label *)
                                        Tokens.LIFETIME_OR_LABEL(yytext, yypos, yypos-1+size yytext); continue())
      end
fun yyAction87 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext); 
                                        Tokens.CHAR_LIT(escape(strip(yytext, #"'"), yypos), yypos, yypos-1+size yytext); continue())
      end
fun yyAction88 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext); 
                                        Tokens.CHAR_LIT(escape(strip(yytext, #"'"), yypos), yypos, yypos-1+size yytext); continue())
      end
fun yyAction89 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext); 
                                        Tokens.CHAR_LIT(escape(strip(yytext, #"'"), yypos), yypos, yypos-1+size yytext); continue())
      end
fun yyAction90 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext); 
                                        Tokens.CHAR_LIT(Char.ord(toChar(strip(yytext, #"'"))), yypos, yypos-1+size yytext); continue())
      end
fun yyAction91 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; lexLog(yypos, yytext);
                                        Tokens.CHAR_LIT(decodeChar(strip(yytext, #"'"), UTF8), yypos, yypos-1+size yytext); continue())
      end
fun yyAction92 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN STR; strList:=nil; strpos:=yypos; lexLog(yypos, "<String>"); continue()))
fun yyAction93 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; lexLog(!strpos, "Tokens.STR_LIT "^strMake()); Tokens.STR_LIT(strMake(), !strpos, yypos)))
fun yyAction94 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(Char.chr(escape(yytext, yypos))); continue())
      end
fun yyAction95 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(Char.chr(escape(yytext, yypos))); continue())
      end
fun yyAction96 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                (* here is a bug. This will raise a exception 
                                when unicode point is bigger than 255 *)
                                strAppend(Char.chr(escape(yytext, yypos))); 
                                continue()
                            )
      end
fun yyAction97 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "String \\n"); incLine(yypos);  continue()))
fun yyAction98 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(toChar(yytext)); incLine(yypos);  continue())
      end
fun yyAction99 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar(yytext)); continue())
      end
fun yyAction100 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN R_STR; strList:=nil; strpos:=yypos; lexLog(yypos, "<Raw string>"); continue()))
fun yyAction101 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; lexLog(!strpos,strMake()); Tokens.RAW_STR_LIT(strMake(), !strpos, yypos)))
fun yyAction102 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (incLine(yypos);  strAppend(toChar yytext); continue())
      end
fun yyAction103 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar yytext); continue())
      end
fun yyAction104 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                YYBEGIN R_STR_BEGIN;
                                strList:=nil; 
                                strpos:=yypos;
                                lsharp := 1; 
                                rsharp := 0; 
                                lexLog(yypos, "<Raw string(#)>"); 
                                continue()
                            ))
fun yyAction105 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lsharp := !lsharp+1; continue()))
fun yyAction106 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN R_STR_BODY; continue()))
fun yyAction107 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (incLine(yypos);  
                                ErrorMsg.error yypos ("illegal character[R_STR_BEGIN] " ^ yytext);
                                continue())
      end
fun yyAction108 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (ErrorMsg.error yypos ("illegal character[R_STR_BEGIN] " ^ yytext); continue())
      end
fun yyAction109 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                lexLog(yypos, "<Raw string(#) end>");
                                app strAppend [#"\"", #"#"];
                                rsharp := 1;
                                if !rsharp = !lsharp then
                                    (YYBEGIN INITIAL;
                                    strList := strPop(!strList, !rsharp+1);
                                    lexLog(!strpos,strMake());
                                    Tokens.RAW_STR_LIT(strMake(), !strpos, yypos))
                                else
                                    (YYBEGIN R_STR_END;
                                    continue())
                            ))
fun yyAction110 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (incLine(yypos);  strAppend(toChar yytext); continue())
      end
fun yyAction111 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar yytext); continue())
      end
fun yyAction112 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                strAppend(toChar yytext);
                                rsharp := !rsharp+1;
                                if !lsharp = !rsharp then
                                    (YYBEGIN INITIAL;
                                    strList := strPop(!strList, !rsharp+1);
                                    lexLog(!strpos,strMake());
                                    Tokens.RAW_STR_LIT(strMake(), !strpos, yypos))
                                else
                                    (continue())
                            )
      end
fun yyAction113 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                strAppend(toChar yytext);
                                YYBEGIN R_STR_BODY;
                                rsharp := 0;
                                continue()
                            )
      end
fun yyAction114 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN BYTE; lexLog(yypos, "<Byte char>"); continue()))
fun yyAction115 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                YYBEGIN INITIAL; 
                                lexLog(yypos, yytext); 
                                Tokens.BYTE_LIT(escape(strip(yytext, #"'"), yypos), yypos, yypos+size yytext)
                            )
      end
fun yyAction116 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                YYBEGIN INITIAL; 
                                lexLog(yypos, yytext); 
                                Tokens.BYTE_LIT(escape(strip(yytext, #"'"), yypos), yypos, yypos+size yytext)
                            )
      end
fun yyAction117 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                YYBEGIN INITIAL; 
                                lexLog(yypos, yytext);
                                Tokens.BYTE_LIT(Char.ord(toChar(strip(yytext, #"'"))), yypos, yypos+size yytext)
                            )
      end
fun yyAction118 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; incLine(yypos);  continue()))
fun yyAction119 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (YYBEGIN INITIAL; ErrorMsg.error yypos ("illegal character[BYTE] " ^ yytext); continue())
      end
fun yyAction120 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN BYTE_STR; strList:=nil; strpos:=yypos; lexLog(yypos, "<Byte string>"); continue()))
fun yyAction121 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; lexLog(!strpos,strMake()); Tokens.BYTE_STR_LIT(strMake(), !strpos, yypos)))
fun yyAction122 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar(yytext)); continue())
      end
fun yyAction123 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(Char.chr(escape(yytext, yypos))); continue())
      end
fun yyAction124 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(Char.chr(escape(yytext, yypos))); continue())
      end
fun yyAction125 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lexLog(yypos, "String \\n"); incLine(yypos);  continue()))
fun yyAction126 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (strAppend(toChar(yytext)); incLine(yypos);  continue())
      end
fun yyAction127 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar(yytext)); continue())
      end
fun yyAction128 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN BR_STR; strList:=nil; strpos:=yypos; lexLog(yypos, "<Raw byte string>"); continue()))
fun yyAction129 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN INITIAL; lexLog(!strpos,strMake()); Tokens.RAW_BYTE_STR_LIT(strMake(), !strpos, yypos)))
fun yyAction130 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (incLine(yypos);  strAppend(toChar yytext); continue())
      end
fun yyAction131 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar yytext); continue())
      end
fun yyAction132 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (ErrorMsg.error yypos ("illegal character[BR_STR] " ^ yytext); continue())
      end
fun yyAction133 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN BR_STR_BEGIN; lsharp := 1; rsharp := 0; lexLog(yypos, "<Raw byte string(#)>"); continue()))
fun yyAction134 (strm, lastMatch : yymatch) = (yystrm := strm;
      (lsharp := !lsharp+1; continue()))
fun yyAction135 (strm, lastMatch : yymatch) = (yystrm := strm;
      (YYBEGIN BR_STR_BODY; continue()))
fun yyAction136 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (incLine(yypos);  
                                     ErrorMsg.error yypos ("illegal character[BR_STR_BEGIN] " ^ yytext);
                                    continue())
      end
fun yyAction137 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (ErrorMsg.error yypos ("illegal character[BR_STR_BEGIN] " ^ yytext); continue())
      end
fun yyAction138 (strm, lastMatch : yymatch) = (yystrm := strm;
      (
                                app strAppend [#"\"", #"#"];
                                rsharp := 1;
                                if !rsharp = !lsharp then
                                    (YYBEGIN INITIAL;
                                    strList := strPop(!strList, !rsharp+1);
                                    lexLog(!strpos,strMake());
                                    Tokens.RAW_BYTE_STR_LIT(strMake(), !strpos, yypos))
                                else
                                    (YYBEGIN BR_STR_END;
                                    continue())
                            ))
fun yyAction139 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (incLine(yypos);  strAppend(toChar yytext); continue())
      end
fun yyAction140 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm; (strAppend(toChar yytext); continue())
      end
fun yyAction141 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (ErrorMsg.error yypos ("illegal character[BR_STR_BODY] " ^ yytext); continue())
      end
fun yyAction142 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                    strAppend(toChar yytext);
                                    rsharp := !rsharp+1;
                                    if !lsharp = !rsharp then
                                        (YYBEGIN INITIAL;
                                        strList := strPop(!strList, !rsharp+1);
                                        lexLog(!strpos,strMake());
                                        Tokens.RAW_STR_LIT(strMake(), !strpos, yypos))
                                    else
                                        (continue())
                            )
      end
fun yyAction143 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                (if (toChar yytext) < #"\128" then
                                    strAppend(toChar yytext)
                                else
                                    (ErrorMsg.error yypos ("illegal character[BR_STR_END] " ^ yytext))
                                );
                                (
                                    if (toChar yytext) = #"\n" then 
                                        (lin := !lin + 1; col := yypos :: !col)
                                    else
                                        ()
                                );
                                YYBEGIN BR_STR_BODY;
                                rsharp := 0;
                                continue()
                            )
      end
fun yyAction144 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                lexLog(yypos, "<Integer> "^yytext); 
                                Tokens.INTEGER_LIT(toInteger(yytext), yypos, yypos+size yytext)
                            )
      end
fun yyAction145 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (
                                lexLog(yypos, "<Float> "^yytext); 
                                Tokens.FLOAT_LIT(toFloat(yytext), yypos, yypos+size yytext)
                            )
      end
fun yyAction146 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SHLEQ(yypos, yypos+size yytext))
      end
fun yyAction147 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SHREQ(yypos, yypos+size yytext))
      end
fun yyAction148 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.DOTDOTDOT(yypos, yypos+size yytext))
      end
fun yyAction149 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.DOTDOTEQ(yypos, yypos+size yytext))
      end
fun yyAction150 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.ANDAND(yypos, yypos+size yytext))
      end
fun yyAction151 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.OROR(yypos, yypos+size yytext))
      end
fun yyAction152 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SHL(yypos, yypos+size yytext))
      end
fun yyAction153 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SHR(yypos, yypos+size yytext))
      end
fun yyAction154 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.PLUSEQ(yypos, yypos+size yytext))
      end
fun yyAction155 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.MINUSEQ(yypos, yypos+size yytext))
      end
fun yyAction156 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.STAREQ(yypos, yypos+size yytext))
      end
fun yyAction157 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SLASHEQ(yypos, yypos+size yytext))
      end
fun yyAction158 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.PERCENTEQ(yypos, yypos+size yytext))
      end
fun yyAction159 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.CARETEQ(yypos, yypos+size yytext))
      end
fun yyAction160 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.ANDEQ(yypos, yypos+size yytext))
      end
fun yyAction161 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.OREQ(yypos, yypos+size yytext))
      end
fun yyAction162 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.EQEQ(yypos, yypos+size yytext))
      end
fun yyAction163 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.NE(yypos, yypos+size yytext))
      end
fun yyAction164 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.GE(yypos, yypos+size yytext))
      end
fun yyAction165 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.LE(yypos, yypos+size yytext))
      end
fun yyAction166 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.RARROW(yypos, yypos+size yytext))
      end
fun yyAction167 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.FATARROW(yypos, yypos+size yytext))
      end
fun yyAction168 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.DOTDOT(yypos, yypos+size yytext))
      end
fun yyAction169 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.PATHSEP(yypos, yypos+size yytext))
      end
fun yyAction170 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.DOT(yypos, yypos+size yytext))
      end
fun yyAction171 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.PLUS(yypos, yypos+size yytext))
      end
fun yyAction172 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.MINUS(yypos, yypos+size yytext))
      end
fun yyAction173 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.STAR(yypos, yypos+size yytext))
      end
fun yyAction174 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SLASH(yypos, yypos+size yytext))
      end
fun yyAction175 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.PERCENT(yypos, yypos+size yytext))
      end
fun yyAction176 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.POUND(yypos, yypos+ size yytext))
      end
fun yyAction177 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.CARET(yypos, yypos+size yytext))
      end
fun yyAction178 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.NOT(yypos, yypos+size yytext))
      end
fun yyAction179 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.AND(yypos, yypos+size yytext))
      end
fun yyAction180 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.OR(yypos, yypos+size yytext))
      end
fun yyAction181 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.EQ "^yytext); Tokens.EQ(yypos, yypos+size yytext))
      end
fun yyAction182 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.GT(yypos, yypos+size yytext))
      end
fun yyAction183 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.LT(yypos, yypos+size yytext))
      end
fun yyAction184 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.AT(yypos, yypos+size yytext))
      end
fun yyAction185 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.COMMA(yypos, yypos+size yytext))
      end
fun yyAction186 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.SEMI(yypos, yypos+size yytext))
      end
fun yyAction187 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.COLON(yypos, yypos+size yytext))
      end
fun yyAction188 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "<Punctuation> "^yytext); Tokens.DOLLAR(yypos, yypos+size yytext))
      end
fun yyAction189 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.QUESTION "^yytext); Tokens.QUESTION(yypos, yypos+size yytext))
      end
fun yyAction190 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.LBRACE "^yytext); Tokens.LBRACE(yypos, yypos+size yytext))
      end
fun yyAction191 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.RBRACE"^yytext); Tokens.RBRACE(yypos, yypos+size yytext))
      end
fun yyAction192 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.LBRACKET "^yytext); Tokens.LBRACKET(yypos, yypos+size yytext))
      end
fun yyAction193 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.RBRACKET "^yytext); Tokens.RBRACKET(yypos, yypos+size yytext))
      end
fun yyAction194 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.LPARENT "^yytext); Tokens.LPARENT(yypos, yypos+size yytext))
      end
fun yyAction195 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (lexLog(yypos, "Tokens.RPARENT "^yytext); Tokens.RPARENT(yypos, yypos+size yytext))
      end
fun yyAction196 (strm, lastMatch : yymatch) = let
      val yytext = yymktext(strm)
      in
        yystrm := strm;
        (ErrorMsg.error yypos ("illegal character[INITIAL] " ^ yytext); continue())
      end
val yyactTable = Vector.fromList([yyAction0, yyAction1, yyAction2, yyAction3,
  yyAction4, yyAction5, yyAction6, yyAction7, yyAction8, yyAction9, yyAction10,
  yyAction11, yyAction12, yyAction13, yyAction14, yyAction15, yyAction16,
  yyAction17, yyAction18, yyAction19, yyAction20, yyAction21, yyAction22,
  yyAction23, yyAction24, yyAction25, yyAction26, yyAction27, yyAction28,
  yyAction29, yyAction30, yyAction31, yyAction32, yyAction33, yyAction34,
  yyAction35, yyAction36, yyAction37, yyAction38, yyAction39, yyAction40,
  yyAction41, yyAction42, yyAction43, yyAction44, yyAction45, yyAction46,
  yyAction47, yyAction48, yyAction49, yyAction50, yyAction51, yyAction52,
  yyAction53, yyAction54, yyAction55, yyAction56, yyAction57, yyAction58,
  yyAction59, yyAction60, yyAction61, yyAction62, yyAction63, yyAction64,
  yyAction65, yyAction66, yyAction67, yyAction68, yyAction69, yyAction70,
  yyAction71, yyAction72, yyAction73, yyAction74, yyAction75, yyAction76,
  yyAction77, yyAction78, yyAction79, yyAction80, yyAction81, yyAction82,
  yyAction83, yyAction84, yyAction85, yyAction86, yyAction87, yyAction88,
  yyAction89, yyAction90, yyAction91, yyAction92, yyAction93, yyAction94,
  yyAction95, yyAction96, yyAction97, yyAction98, yyAction99, yyAction100,
  yyAction101, yyAction102, yyAction103, yyAction104, yyAction105, yyAction106,
  yyAction107, yyAction108, yyAction109, yyAction110, yyAction111, yyAction112,
  yyAction113, yyAction114, yyAction115, yyAction116, yyAction117, yyAction118,
  yyAction119, yyAction120, yyAction121, yyAction122, yyAction123, yyAction124,
  yyAction125, yyAction126, yyAction127, yyAction128, yyAction129, yyAction130,
  yyAction131, yyAction132, yyAction133, yyAction134, yyAction135, yyAction136,
  yyAction137, yyAction138, yyAction139, yyAction140, yyAction141, yyAction142,
  yyAction143, yyAction144, yyAction145, yyAction146, yyAction147, yyAction148,
  yyAction149, yyAction150, yyAction151, yyAction152, yyAction153, yyAction154,
  yyAction155, yyAction156, yyAction157, yyAction158, yyAction159, yyAction160,
  yyAction161, yyAction162, yyAction163, yyAction164, yyAction165, yyAction166,
  yyAction167, yyAction168, yyAction169, yyAction170, yyAction171, yyAction172,
  yyAction173, yyAction174, yyAction175, yyAction176, yyAction177, yyAction178,
  yyAction179, yyAction180, yyAction181, yyAction182, yyAction183, yyAction184,
  yyAction185, yyAction186, yyAction187, yyAction188, yyAction189, yyAction190,
  yyAction191, yyAction192, yyAction193, yyAction194, yyAction195, yyAction196])
in
  if yyInput.eof(!(yystrm))
    then UserDeclarations.eof(yyarg)
    else (case (!(yyss))
       of STR => yygo yyactTable (0, !(yystrm), yyNO_MATCH)
        | BYTE => yygo yyactTable (1, !(yystrm), yyNO_MATCH)
        | SUFFIX => yygo yyactTable (2, !(yystrm), yyNO_MATCH)
        | R_STR_END => yygo yyactTable (3, !(yystrm), yyNO_MATCH)
        | BLOCK_COMMENT => yygo yyactTable (4, !(yystrm), yyNO_MATCH)
        | INNER_LINE_DOC => yygo yyactTable (5, !(yystrm), yyNO_MATCH)
        | BR_STR_BEGIN => yygo yyactTable (6, !(yystrm), yyNO_MATCH)
        | OUTER_BLOCK_DOC => yygo yyactTable (7, !(yystrm), yyNO_MATCH)
        | BYTE_STR => yygo yyactTable (8, !(yystrm), yyNO_MATCH)
        | LINE_COMMENT => yygo yyactTable (9, !(yystrm), yyNO_MATCH)
        | POUND => yygo yyactTable (10, !(yystrm), yyNO_MATCH)
        | R_STR => yygo yyactTable (11, !(yystrm), yyNO_MATCH)
        | LIFE_OR_CHAR => yygo yyactTable (12, !(yystrm), yyNO_MATCH)
        | SHEBANG_OR_ATTR => yygo yyactTable (10, !(yystrm), yyNO_MATCH)
        | INNER_BLOCK_DOC => yygo yyactTable (13, !(yystrm), yyNO_MATCH)
        | BR_STR_BODY => yygo yyactTable (14, !(yystrm), yyNO_MATCH)
        | OUTER_LINE_DOC => yygo yyactTable (15, !(yystrm), yyNO_MATCH)
        | R_STR_BEGIN => yygo yyactTable (16, !(yystrm), yyNO_MATCH)
        | R_STR_BODY => yygo yyactTable (17, !(yystrm), yyNO_MATCH)
        | BR_STR => yygo yyactTable (18, !(yystrm), yyNO_MATCH)
        | INITIAL => yygo yyactTable (19, !(yystrm), yyNO_MATCH)
        | BR_STR_END => yygo yyactTable (20, !(yystrm), yyNO_MATCH)
      (* end case *))
end
            end
	  in 
            continue() 	  
	    handle IO.Io{cause, ...} => raise cause
          end
        in 
          lex 
        end
    in
    fun makeLexer yyinputN = mk (yyInput.mkStream yyinputN)
    end

  end
